CCS PCH C Compiler, Version 4.120, 5967               02-abr.-14 22:04

               Filename: C:\Users\Jannier\Documents\Proyectos Ingenieria\pinguino HACK\Pinguino JACSS\Ejemplos\8_LCDGRAFICA\LCDGRAFICA.lst

               ROM used: 15228 bytes (46%)
                         Largest free fragment is 9344
               RAM used: 1265 (62%) at main() level
                         1335 (65%) worst case
               Stack:    5 locations

*
2000:  GOTO   42D8
.................... #include <18F4550.h>  
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL5,CPUDIV1,VREGEN,NOPBADEN 
.................... //#use delay(clock=48000000)  //#use delay(clock=20000000) 
.................... #include <usb_bootloader.h> //Comenta esta línea si no usas Bootloader 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                     USB_BOOTLOADER.H                              //// 
.................... ////                                                                   //// 
.................... ////  This include file must be included by any application loaded     //// 
.................... ////  by the example USB bootloader (ex_usb_bootloader                 //// 
.................... ////                                                                   //// 
.................... ////  The directives in this file relocate the reset and interrupt     //// 
.................... ////  vectors as well as reserving space for the bootloader.           //// 
.................... ////                                                                   //// 
.................... ////  For more documentation see ex_usb_bootloader.c                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// VERSION HISTORY                                                   //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //how big is the bootloader? 
.................... //the bootloader will reside from address 0x0000 to this location.  the 
.................... //application will then sit at this location+1 to the end of program memory. 
.................... //#if defined(__DEBUG) 
.................... #define LOADER_SIZE        (0x1FFF) 
.................... //#else 
.................... //#define LOADER_SIZE        (0x17FF) 
.................... //#endif 
....................  
.................... //the loader and application need a common flag that determines if we are in 
.................... //the bootloader or application, that way the ISR knows where to go.  this 
.................... //is the location in ram that is reserved for this flag. 
.................... #define LOC_IN_LOADER_FLAG  0x25 
....................  
.................... //// --- end configuration --- //////////////////////////////////////////// 
....................  
.................... #reserve LOC_IN_LOADER_FLAG 
....................  
.................... int8 g_InBootloader; 
.................... #locate g_InBootloader=LOC_IN_LOADER_FLAG 
....................  
.................... #define LOADER_START       (0) 
.................... #define LOADER_END         (LOADER_SIZE) 
.................... #define APPLICATION_START  (LOADER_SIZE+1) 
.................... #if defined(__USB_87J50__) 
....................  #define APPLICATION_END    (getenv("PROGRAM_MEMORY")-9) //configuration bits 
.................... #else 
....................  #define APPLICATION_END    (getenv("PROGRAM_MEMORY")-1) 
.................... #endif  
.................... #define APPLICATION_ISR    (APPLICATION_START+8) 
....................  
.................... #ifdef _bootloader 
....................  /* 
....................   Provide an empty application, so if you load this .HEX file into the pic 
....................   without an application this will prevent the pic from executing unknown code. 
....................  */ 
....................  #org APPLICATION_START,APPLICATION_START+0xF 
....................  void BlankApplication(void)  
....................  { 
....................    while(TRUE); 
....................  } 
....................  
....................  //we need to prevent the loader from using application space 
....................  #if (APPLICATION_END > 0x10000) 
....................    #org APPLICATION_START+0x10, 0xFFFF {} 
....................    #if (APPLICATION_END > 0x20000) 
....................       #org 0x10000, 0x1FFFF {} 
....................       #org 0x20000, APPLICATION_END {} 
....................    #else 
....................       #org 0x10000, APPLICATION_END {} 
....................    #endif 
....................  #else 
....................    #org APPLICATION_START+0x10, APPLICATION_END {} 
....................  #endif 
....................  
....................    #define  USB_CONFIG_PID       0x0034 
....................  
....................    #define USB_STRINGS_OVERWRITTEN 
....................    char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
....................    // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored. 
....................    // Strings are saved as unicode. 
....................    // These strings are mostly only displayed during the add hardware wizard. 
....................    // Once the operating system drivers have been installed it will usually display 
....................    // the name from the drivers .INF. 
....................    char const USB_STRING_DESC[]={ 
....................       //string 0 
....................             4, //length of string index 
....................             0x03, //USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................             0x09,0x04,   //Microsoft Defined for US-English 
....................       //string 1  - manufacturer 
....................             8, //length of string index 
....................             0x03, //USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................             'C',0, 
....................             'C',0, 
....................             'S',0, 
....................       //string 2 - product 
....................             30, //length of string index 
....................             0x03, //USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................             'C',0, 
....................             'D',0, 
....................             'C',0, 
....................             ' ',0, 
....................             'B',0, 
....................             'o',0, 
....................             'o',0, 
....................             't',0, 
....................             'l',0, 
....................             'o',0, 
....................             'a',0, 
....................             'd',0, 
....................             'e',0, 
....................             'r',0 
....................    }; 
.................... #endif   //_bootloader 
....................  
.................... #ifndef _bootloader 
....................  //in the application, this moves the reset and isr vector out of the bootload 
....................  //space.  it then reserves the loader space from being used by the application. 
....................  #build(reset=APPLICATION_START, interrupt=APPLICATION_ISR) 
....................  #org 0, LOADER_END {} 
.................... #endif 
....................  
.................... #USE DELAY (Clock = 20000000) 
*
2926:  MOVLW  03
2928:  MOVLB  5
292A:  SUBWF  x0E,F
292C:  BNC   2942
292E:  MOVLW  05
2930:  MOVWF  FEA
2932:  MOVLW  0E
2934:  MOVWF  FE9
2936:  MOVF   FEF,W
2938:  BZ    2942
293A:  BRA    293E
293C:  BRA    293E
293E:  DECFSZ FEF,F
2940:  BRA    293C
2942:  MOVLB  0
2944:  GOTO   2A2C (RETURN)
2948:  MOVLW  05
294A:  MOVWF  FEA
294C:  MOVLW  0F
294E:  MOVWF  FE9
2950:  MOVF   FEF,W
2952:  BZ    296E
2954:  MOVLW  06
2956:  MOVWF  01
2958:  CLRF   00
295A:  DECFSZ 00,F
295C:  BRA    295A
295E:  DECFSZ 01,F
2960:  BRA    2958
2962:  MOVLW  7B
2964:  MOVWF  00
2966:  DECFSZ 00,F
2968:  BRA    2966
296A:  DECFSZ FEF,F
296C:  BRA    2954
296E:  RETURN 0
....................  
.................... #USE RS232 (BAUD = 57600, UART1) 
....................  
.................... #INCLUDE <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
*
3412:  MOVLB  5
3414:  CLRF   x29
3416:  CLRF   x28
3418:  CLRF   x27
341A:  MOVLW  7F
341C:  MOVWF  x26
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
341E:  MOVLW  7E
3420:  MOVWF  x30
3422:  MOVLW  80
3424:  MOVWF  x31
3426:  CLRF   x32
3428:  CLRF   x33
342A:  MOVLW  7A
342C:  MOVWF  x34
342E:  MOVLW  2A
3430:  MOVWF  x35
3432:  MOVLW  AA
3434:  MOVWF  x36
3436:  MOVLW  A3
3438:  MOVWF  x37
343A:  MOVLW  75
343C:  MOVWF  x38
343E:  MOVLW  B6
3440:  MOVWF  x39
3442:  MOVLW  09
3444:  MOVWF  x3A
3446:  MOVLW  B4
3448:  MOVWF  x3B
344A:  MOVLW  6F
344C:  MOVWF  x3C
344E:  MOVLW  4F
3450:  MOVWF  x3D
3452:  MOVLW  B6
3454:  MOVWF  x3E
3456:  MOVLW  AA
3458:  MOVWF  x3F
345A:  MOVLW  69
345C:  MOVWF  x40
345E:  MOVLW  8B
3460:  MOVWF  x41
3462:  MOVLW  F6
3464:  MOVWF  x42
3466:  MOVLW  E8
3468:  MOVWF  x43
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
346A:  MOVFF  51D,547
346E:  MOVFF  51C,546
3472:  MOVFF  51B,545
3476:  MOVFF  51A,544
347A:  CLRF   x4B
347C:  CLRF   x4A
347E:  CLRF   x49
3480:  CLRF   x48
3482:  MOVLB  0
3484:  RCALL  3326
3486:  BNC   3490
3488:  MOVLB  5
348A:  MOVF   x1B,W
348C:  XORLW  80
348E:  MOVWF  x1B
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
3490:  MOVFF  51D,54B
3494:  MOVFF  51C,54A
3498:  MOVFF  51B,549
349C:  MOVFF  51A,548
34A0:  MOVLW  83
34A2:  MOVLB  5
34A4:  MOVWF  x4F
34A6:  MOVLW  F9
34A8:  MOVWF  x4E
34AA:  MOVLW  22
34AC:  MOVWF  x4D
34AE:  MOVLW  7E
34B0:  MOVWF  x4C
34B2:  MOVLB  0
34B4:  RCALL  2E5A
34B6:  MOVFF  03,547
34BA:  MOVFF  02,546
34BE:  MOVFF  01,545
34C2:  MOVFF  00,544
34C6:  RCALL  33A0
34C8:  MOVFF  01,52A
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
34CC:  MOVFF  51D,54B
34D0:  MOVFF  51C,54A
34D4:  MOVFF  51B,549
34D8:  MOVFF  51A,548
34DC:  MOVLW  83
34DE:  MOVLB  5
34E0:  MOVWF  x4F
34E2:  MOVLW  F9
34E4:  MOVWF  x4E
34E6:  MOVLW  22
34E8:  MOVWF  x4D
34EA:  MOVLW  7E
34EC:  MOVWF  x4C
34EE:  MOVLB  0
34F0:  RCALL  2E5A
34F2:  MOVFF  00,544
34F6:  MOVFF  01,545
34FA:  MOVFF  02,546
34FE:  MOVFF  03,547
3502:  MOVLB  5
3504:  CLRF   x49
3506:  MOVFF  52A,548
350A:  MOVLB  0
350C:  RCALL  33DC
350E:  BSF    FD8.1
3510:  MOVFF  547,54B
3514:  MOVFF  546,54A
3518:  MOVFF  545,549
351C:  MOVFF  544,548
3520:  MOVFF  03,54F
3524:  MOVFF  02,54E
3528:  MOVFF  01,54D
352C:  MOVFF  00,54C
3530:  RCALL  30AE
3532:  MOVFF  03,52F
3536:  MOVFF  02,52E
353A:  MOVFF  01,52D
353E:  MOVFF  00,52C
....................    quad = quad % 4;                    // quadrant (0 to 3) 
3542:  MOVLW  03
3544:  MOVLB  5
3546:  ANDWF  x2A,F
....................  
....................    if (quad == 0 || quad == 2) 
3548:  MOVF   x2A,F
354A:  BZ    3552
354C:  MOVF   x2A,W
354E:  SUBLW  02
3550:  BNZ   358A
....................       t = frac * PI_DIV_BY_TWO; 
3552:  MOVFF  52F,54B
3556:  MOVFF  52E,54A
355A:  MOVFF  52D,549
355E:  MOVFF  52C,548
3562:  MOVLW  DB
3564:  MOVWF  x4F
3566:  MOVLW  0F
3568:  MOVWF  x4E
356A:  MOVLW  49
356C:  MOVWF  x4D
356E:  MOVLW  7F
3570:  MOVWF  x4C
3572:  MOVLB  0
3574:  RCALL  2E5A
3576:  MOVFF  03,525
357A:  MOVFF  02,524
357E:  MOVFF  01,523
3582:  MOVFF  00,522
....................    else if (quad == 1) 
3586:  BRA    365E
3588:  MOVLB  5
358A:  DECFSZ x2A,W
358C:  BRA    35F8
....................       t = (1-frac) * PI_DIV_BY_TWO; 
358E:  BSF    FD8.1
3590:  CLRF   x4B
3592:  CLRF   x4A
3594:  CLRF   x49
3596:  MOVLW  7F
3598:  MOVWF  x48
359A:  MOVFF  52F,54F
359E:  MOVFF  52E,54E
35A2:  MOVFF  52D,54D
35A6:  MOVFF  52C,54C
35AA:  MOVLB  0
35AC:  RCALL  30AE
35AE:  MOVFF  00,544
35B2:  MOVFF  01,545
35B6:  MOVFF  02,546
35BA:  MOVFF  03,547
35BE:  MOVFF  03,54B
35C2:  MOVFF  02,54A
35C6:  MOVFF  01,549
35CA:  MOVFF  00,548
35CE:  MOVLW  DB
35D0:  MOVLB  5
35D2:  MOVWF  x4F
35D4:  MOVLW  0F
35D6:  MOVWF  x4E
35D8:  MOVLW  49
35DA:  MOVWF  x4D
35DC:  MOVLW  7F
35DE:  MOVWF  x4C
35E0:  MOVLB  0
35E2:  RCALL  2E5A
35E4:  MOVFF  03,525
35E8:  MOVFF  02,524
35EC:  MOVFF  01,523
35F0:  MOVFF  00,522
....................    else // should be 3 
35F4:  BRA    365E
35F6:  MOVLB  5
....................       t = (frac-1) * PI_DIV_BY_TWO; 
35F8:  BSF    FD8.1
35FA:  MOVFF  52F,54B
35FE:  MOVFF  52E,54A
3602:  MOVFF  52D,549
3606:  MOVFF  52C,548
360A:  CLRF   x4F
360C:  CLRF   x4E
360E:  CLRF   x4D
3610:  MOVLW  7F
3612:  MOVWF  x4C
3614:  MOVLB  0
3616:  RCALL  30AE
3618:  MOVFF  00,544
361C:  MOVFF  01,545
3620:  MOVFF  02,546
3624:  MOVFF  03,547
3628:  MOVFF  03,54B
362C:  MOVFF  02,54A
3630:  MOVFF  01,549
3634:  MOVFF  00,548
3638:  MOVLW  DB
363A:  MOVLB  5
363C:  MOVWF  x4F
363E:  MOVLW  0F
3640:  MOVWF  x4E
3642:  MOVLW  49
3644:  MOVWF  x4D
3646:  MOVLW  7F
3648:  MOVWF  x4C
364A:  MOVLB  0
364C:  RCALL  2E5A
364E:  MOVFF  03,525
3652:  MOVFF  02,524
3656:  MOVFF  01,523
365A:  MOVFF  00,522
....................  
....................    y = 1.0; 
365E:  MOVLB  5
3660:  CLRF   x21
3662:  CLRF   x20
3664:  CLRF   x1F
3666:  MOVLW  7F
3668:  MOVWF  x1E
....................    t = t * t; 
366A:  MOVFF  525,54B
366E:  MOVFF  524,54A
3672:  MOVFF  523,549
3676:  MOVFF  522,548
367A:  MOVFF  525,54F
367E:  MOVFF  524,54E
3682:  MOVFF  523,54D
3686:  MOVFF  522,54C
368A:  MOVLB  0
368C:  CALL   2E5A
3690:  MOVFF  03,525
3694:  MOVFF  02,524
3698:  MOVFF  01,523
369C:  MOVFF  00,522
....................    for (i = 0; i <= 4; i++) 
36A0:  MOVLB  5
36A2:  CLRF   x2B
36A4:  MOVF   x2B,W
36A6:  SUBLW  04
36A8:  BNC   3774
....................    { 
....................       t2 = t2 * t; 
36AA:  MOVFF  529,54B
36AE:  MOVFF  528,54A
36B2:  MOVFF  527,549
36B6:  MOVFF  526,548
36BA:  MOVFF  525,54F
36BE:  MOVFF  524,54E
36C2:  MOVFF  523,54D
36C6:  MOVFF  522,54C
36CA:  MOVLB  0
36CC:  CALL   2E5A
36D0:  MOVFF  03,529
36D4:  MOVFF  02,528
36D8:  MOVFF  01,527
36DC:  MOVFF  00,526
....................       y = y + p[i] * t2; 
36E0:  MOVLB  5
36E2:  MOVF   x2B,W
36E4:  MULLW  04
36E6:  MOVF   FF3,W
36E8:  CLRF   03
36EA:  ADDLW  30
36EC:  MOVWF  FE9
36EE:  MOVLW  05
36F0:  ADDWFC 03,W
36F2:  MOVWF  FEA
36F4:  MOVFF  FEF,544
36F8:  MOVFF  FEC,545
36FC:  MOVFF  FEC,546
3700:  MOVFF  FEC,547
3704:  MOVFF  547,54B
3708:  MOVFF  546,54A
370C:  MOVFF  545,549
3710:  MOVFF  544,548
3714:  MOVFF  529,54F
3718:  MOVFF  528,54E
371C:  MOVFF  527,54D
3720:  MOVFF  526,54C
3724:  MOVLB  0
3726:  CALL   2E5A
372A:  MOVFF  FEA,545
372E:  MOVFF  FE9,544
3732:  BCF    FD8.1
3734:  MOVFF  521,54B
3738:  MOVFF  520,54A
373C:  MOVFF  51F,549
3740:  MOVFF  51E,548
3744:  MOVFF  03,54F
3748:  MOVFF  02,54E
374C:  MOVFF  01,54D
3750:  MOVFF  00,54C
3754:  RCALL  30AE
3756:  MOVFF  545,FEA
375A:  MOVFF  544,FE9
375E:  MOVFF  03,521
3762:  MOVFF  02,520
3766:  MOVFF  01,51F
376A:  MOVFF  00,51E
....................    } 
376E:  MOVLB  5
3770:  INCF   x2B,F
3772:  BRA    36A4
....................  
....................    if (quad == 2 || quad == 1) 
3774:  MOVF   x2A,W
3776:  SUBLW  02
3778:  BZ    377E
377A:  DECFSZ x2A,W
377C:  BRA    3784
....................       y = -y;  // correct sign 
377E:  MOVF   x1F,W
3780:  XORLW  80
3782:  MOVWF  x1F
....................  
....................    return (y); 
3784:  MOVFF  51E,00
3788:  MOVFF  51F,01
378C:  MOVFF  520,02
3790:  MOVFF  521,03
.................... } 
3794:  MOVLB  0
3796:  GOTO   37E4 (RETURN)
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
379A:  BSF    FD8.1
379C:  MOVFF  515,54B
37A0:  MOVFF  514,54A
37A4:  MOVFF  513,549
37A8:  MOVFF  512,548
37AC:  MOVLW  DB
37AE:  MOVLB  5
37B0:  MOVWF  x4F
37B2:  MOVLW  0F
37B4:  MOVWF  x4E
37B6:  MOVLW  49
37B8:  MOVWF  x4D
37BA:  MOVLW  7F
37BC:  MOVWF  x4C
37BE:  MOVLB  0
37C0:  RCALL  30AE
37C2:  MOVFF  00,516
37C6:  MOVFF  01,517
37CA:  MOVFF  02,518
37CE:  MOVFF  03,519
37D2:  MOVFF  03,51D
37D6:  MOVFF  02,51C
37DA:  MOVFF  01,51B
37DE:  MOVFF  00,51A
37E2:  BRA    3412
.................... } 
37E4:  RETURN 0
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #INCLUDE "nokia_LCD.c" 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // DESCRIPCIÓN DE LAS FUNCIONES 
.................... // 
.................... // void nokia_write_dorc(byte bytefornokia)              USO INTERNO 
.................... // void nokia_write_data(byte bytefornokia_data)         USO INTERNO 
.................... // void nokia_printchar(byte caracter)                   IMPRIME EL CARACTER 
.................... // void nokia_write_command(byte bytefornokia_command)   MANDA EL COMANDO 
.................... // void nokia_gotoxy(byte xnokia, byte ynokia)           SE POSICIONA EN X/Y 
.................... // void nokia_clean_ddram(void)                          LIMPIA LA PANTALLA 
.................... // void Lcd_init(void)                                   INICIALIZA LA LCD 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // CONFIGURACION DE LA CONEXION 
.................... // 
.................... // Conectamos la LCD al PORTB en los pines indicados 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... #DEFINE Pin_Nok_SClk PIN_A0 
.................... #DEFINE Pin_Nok_SDa  PIN_A1 
.................... #DEFINE Pin_Nok_DC   PIN_A2 
.................... #DEFINE Pin_Nok_CS   PIN_A3 
.................... #DEFINE Pin_Nok_Res  PIN_A4 
.................... // FIN CONFIGURACION 
....................  
.................... #define NEGRITA      0  // 7x8 
.................... #define COMPRIMIDA   1  // 3x6 
.................... #define NORMAL       2  // 5x7 
....................  
.................... #define NEGRO        1 
.................... #define BLANCO       0 
....................  
.................... #define SOLIDO       1 
.................... #define TRANSPARENTE 0 
....................  
.................... #define ANCHOPANTALLA   84 
.................... #define ALTOPANTALLA    48 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /* 
.................... Tabla de Instrucciones de la LCD. Siempre con D/C=0 
....................  
.................... 0010 0xyz         // X=1 -> Driver en OFF 
....................                      Y=1 -> Direccionamiento Vertical 
....................                      Z=1 -> Comandos Extendidos 
....................  
.................... Modo de pantalla 
.................... 0000 1001   0x09   // Entera Negra 
.................... 0000 1000   0x08   // Entera Blanco 
.................... 0000 1100   0x0c   // Modo Normal 
.................... 0000 1101   0x0d   // Vídeo Inverso 
....................  
.................... Control de Temperatura 
.................... 0100 0100   0x44  // Coeficiente de temperatura 0 
.................... 0100 0101   0x45  // Coeficiente de temperatura 1 
.................... 0100 0110   0x46  // Coeficiente de temperatura 2 
.................... 0100 0111   0x47  // Coeficiente de temperatura 3 
....................  
.................... Bias (Contraste?) 
.................... 0001 0xxx         // Establece el valor para Bias 
....................  
.................... Vop 
.................... 1xxx xxxx         // Establece el valor para Vop 
.................... */ 
....................  
.................... char MemoriaVideo[504]; 
....................  
.................... // F1-ñ -> 0xFC,0x09,0x05,0x05,0xF8 
.................... // D1-Ñ ->        
.................... int8 const ASCII_TABLE[490]={ 
....................                   0x00,0x00,0x00,0x00,0x00,   // 20 space 
....................                   0x00,0x00,0x5f,0x00,0x00,   // 21 ! 
....................                   0x00,0x07,0x00,0x07,0x00,   // 22 " 
....................                   0x14,0x7f,0x14,0x7f,0x14,   // 23 # 
....................                   0x24,0x2a,0x7f,0x2a,0x12,   // 24 $ 
....................                   0x23,0x13,0x08,0x64,0x62,   // 25 % 
....................                   0x36,0x49,0x55,0x22,0x50,   // 26 & 
....................                   0x00,0x05,0x03,0x00,0x00,   // 27 ' 
....................                   0x00,0x1c,0x22,0x41,0x00,   // 28 ( 
....................                   0x00,0x41,0x22,0x1c,0x00,   // 29 ) 
....................                   0x14,0x08,0x3e,0x08,0x14,   // 2a * 
....................                   0x08,0x08,0x3e,0x08,0x08,   // 2b + 
....................                   0x00,0x50,0x30,0x00,0x00,   // 2c , 
....................                   0x08,0x08,0x08,0x08,0x08,   // 2d - 
....................                   0x00,0x60,0x60,0x00,0x00,   // 2e . 
....................                   0x20,0x10,0x08,0x04,0x02,   // 2f / 
....................                   0x3e,0x51,0x49,0x45,0x3e,   // 30 0 
....................                   0x00,0x42,0x7f,0x40,0x00,   // 31 1 
....................                   0x42,0x61,0x51,0x49,0x46,   // 32 2 
....................                   0x21,0x41,0x45,0x4b,0x31,   // 33 3 
....................                   0x18,0x14,0x12,0x7f,0x10,   // 34 4 
....................                   0x27,0x45,0x45,0x45,0x39,   // 35 5 
....................                   0x3c,0x4a,0x49,0x49,0x30,   // 36 6 
....................                   0x01,0x71,0x09,0x05,0x03,   // 37 7 
....................                   0x36,0x49,0x49,0x49,0x36,   // 38 8 
....................                   0x06,0x49,0x49,0x29,0x1e,   // 39 9 
....................                   0x00,0x36,0x36,0x00,0x00,   // 3a : 
....................                   0x00,0x56,0x36,0x00,0x00,   // 3b ; 
....................                   0x08,0x14,0x22,0x41,0x00,   // 3c < 
....................                   0x14,0x14,0x14,0x14,0x14,   // 3d = 
....................                   0x00,0x41,0x22,0x14,0x08,   // 3e > 
....................                   0x02,0x01,0x51,0x09,0x06,   // 3f ? 
....................                   0x32,0x49,0x79,0x41,0x3e,   // 40 @ 
....................                   0x7e,0x11,0x11,0x11,0x7e,   // 41 A 
....................                   0x7f,0x49,0x49,0x49,0x36,   // 42 B 
....................                   0x3e,0x41,0x41,0x41,0x22,   // 43 C 
....................                   0x7f,0x41,0x41,0x22,0x1c,   // 44 D 
....................                   0x7f,0x49,0x49,0x49,0x41,   // 45 E 
....................                   0x7f,0x09,0x09,0x09,0x01,   // 46 F 
....................                   0x3e,0x41,0x49,0x49,0x7a,   // 47 G 
....................                   0x7f,0x08,0x08,0x08,0x7f,   // 48 H 
....................                   0x00,0x41,0x7f,0x41,0x00,   // 49 I 
....................                   0x20,0x40,0x41,0x3f,0x01,   // 4a J 
....................                   0x7f,0x08,0x14,0x22,0x41,   // 4b K 
....................                   0x7f,0x40,0x40,0x40,0x40,   // 4c L 
....................                   0x7f,0x02,0x0c,0x02,0x7f,   // 4d M 
....................                   0x7f,0x04,0x08,0x10,0x7f,   // 4e N 
....................                   0x3e,0x41,0x41,0x41,0x3e,   // 4f O ////////////////////////////////                   
....................                   0x7f,0x09,0x09,0x09,0x06,   // 50 P 
....................                   0x3e,0x41,0x51,0x21,0x5e,   // 51 Q 
....................                   0x7f,0x09,0x19,0x29,0x46,   // 52 R 
....................                   0x46,0x49,0x49,0x49,0x31,   // 53 S 
....................                   0x01,0x01,0x7f,0x01,0x01,   // 54 T 
....................                   0x3f,0x40,0x40,0x40,0x3f,   // 55 U 
....................                   0x1f,0x20,0x40,0x20,0x1f,   // 56 V 
....................                   0x3f,0x40,0x38,0x40,0x3f,   // 57 W 
....................                   0x63,0x14,0x08,0x14,0x63,   // 58 X 
....................                   0x07,0x08,0x70,0x08,0x07,   // 59 Y 
....................                   0x61,0x51,0x49,0x45,0x43,   // 5a Z 
....................                   0x00,0x7f,0x41,0x41,0x00,   // 5b [ 
....................                   0x02,0x04,0x08,0x10,0x20,   // 5c 
....................                   0x00,0x41,0x41,0x7f,0x00,   // 5d 
....................                   0x04,0x02,0x01,0x02,0x04,   // 5e 
....................                   0x40,0x40,0x40,0x40,0x40,   // 5f 
....................                   0x00,0x01,0x02,0x04,0x00,   // 60 
....................                   0x20,0x54,0x54,0x54,0x78,   // 61 a 
....................                   0x7f,0x48,0x44,0x44,0x38,   // 62 b 
....................                   0x38,0x44,0x44,0x44,0x20,   // 63 c 
....................                   0x38,0x44,0x44,0x48,0x7f,   // 64 d 
....................                   0x38,0x54,0x54,0x54,0x18,   // 65 e 
....................                   0x08,0x7e,0x09,0x01,0x02,   // 66 f 
....................                   0x0c,0x52,0x52,0x52,0x3e,   // 67 g 
....................                   0x7f,0x08,0x04,0x04,0x78,   // 68 h 
....................                   0x00,0x44,0x7d,0x40,0x00,   // 69 i 
....................                   0x20,0x40,0x44,0x3d,0x00,   // 6a j 
....................                   0x7f,0x10,0x28,0x44,0x00,   // 6b k 
....................                   0x00,0x41,0x7f,0x40,0x00,   // 6c l 
....................                   0x7c,0x04,0x18,0x04,0x78,   // 6d m 
....................                   0x7c,0x08,0x04,0x04,0x78,   // 6e n 
....................                   0x38,0x44,0x44,0x44,0x38,   // 6f o 
....................                   0x7c,0x14,0x14,0x14,0x08,   // 70 p 
....................                   0x08,0x14,0x14,0x18,0x7c,   // 71 q 
....................                   0x7c,0x08,0x04,0x04,0x08,   // 72 r 
....................                   0x48,0x54,0x54,0x54,0x20,   // 73 s 
....................                   0x04,0x3f,0x44,0x40,0x20,   // 74 t 
....................                   0x3c,0x40,0x40,0x20,0x7c,   // 75 u 
....................                   0x1c,0x20,0x40,0x20,0x1c,   // 76 v 
....................                   0x3c,0x40,0x30,0x40,0x3c,   // 77 w 
....................                   0x44,0x28,0x10,0x28,0x44,   // 78 x 
....................                   0x0c,0x50,0x50,0x50,0x3c,   // 79 y 
....................                   0x44,0x64,0x54,0x4c,0x44,   // 7a z 
....................                   0x00,0x08,0x36,0x41,0x00,   // 7b 
....................                   0x00,0x00,0x7f,0x00,0x00,   // 7c 
....................                   0x00,0x41,0x36,0x08,0x00,   // 7d 
....................                   0x10,0x08,0x08,0x10,0x08,   // 7e 
....................                   0x78,0x46,0x41,0x46,0x78,  // 7F 
....................                   0x7C,0x09,0x05,0x05,0x78,  // 80 -> ñ 
....................                   0x7E,0x05,0x09,0x11,0x7E   // 81 -> Ñ 
....................                   };   // 7f 
....................    
....................    
.................... char const Fuente_3_6 [195]={   /* System 3x6 (char #32 to #96) */ 
....................           0x00,0x00,0x00, /* Espace   0x20 */ 
....................           0x00,0x5C,0x00, /* ! */ 
....................           0x0C,0x00,0x0C, /* " */ 
....................           0x7C,0x28,0x7C, /* # */ 
....................           0x7C,0x44,0x7C, /* 0x */ 
....................           0x24,0x10,0x48, /* % */ 
....................           0x28,0x54,0x08, /* & */ 
....................           0x00,0x0C,0x00, /* ' */ 
....................           0x38,0x44,0x00, /* ( */ 
....................           0x44,0x38,0x00, /* ) */ 
....................           0x20,0x10,0x08, /* // */ 
....................           0x10,0x38,0x10, /* + */ 
....................           0x80,0x40,0x00, /* , */ 
....................           0x10,0x10,0x10, /* - */ 
....................           0x00,0x40,0x00, /* . */ 
....................           0x20,0x10,0x08, /* / */ 
....................           0x38,0x44,0x38, /* 0   0x30 */ 
....................           0x00,0x7C,0x00, /* 1 */ 
....................           0x64,0x54,0x48, /* 2 */ 
....................           0x44,0x54,0x28, /* 3 */ 
....................           0x1C,0x10,0x7C, /* 4 */ 
....................           0x4C,0x54,0x24, /* 5 */ 
....................           0x38,0x54,0x20, /* 6 */ 
....................           0x04,0x74,0x0C, /* 7 */ 
....................           0x28,0x54,0x28, /* 8 */ 
....................           0x08,0x54,0x38, /* 9 */ 
....................           0x00,0x50,0x00, /* : */ 
....................           0x80,0x50,0x00, /* ; */ 
....................           0x10,0x28,0x44, /* < */ 
....................           0x28,0x28,0x28, /* = */ 
....................           0x44,0x28,0x10, /* > */ 
....................           0x04,0x54,0x08, /* ? */ 
....................           0x38,0x4C,0x5C, /* @   0x40 */ 
....................           0x78,0x14,0x78, /* A */ 
....................           0x7C,0x54,0x28, /* B */ 
....................           0x38,0x44,0x44, /* C */ 
....................           0x7C,0x44,0x38, /* D */ 
....................           0x7C,0x54,0x44, /* E */ 
....................           0x7C,0x14,0x04, /* F */ 
....................           0x38,0x44,0x34, /* G */ 
....................           0x7C,0x10,0x7C, /* H */ 
....................           0x00,0x7C,0x00, /* I */ 
....................           0x20,0x40,0x3C, /* J */ 
....................           0x7C,0x10,0x6C, /* K */ 
....................           0x7C,0x40,0x40, /* L */ 
....................           0x7C,0x08,0x7C, /* M */ 
....................           0x7C,0x04,0x7C, /* N */ 
....................           0x7C,0x44,0x7C, /* O */ 
....................           0x7C,0x14,0x08, /* P   0x50 */ 
....................           0x38,0x44,0x78, /* Q */ 
....................           0x7C,0x14,0x68, /* R */ 
....................           0x48,0x54,0x24, /* S */ 
....................           0x04,0x7C,0x04, /* T */ 
....................           0x7C,0x40,0x7C, /* U */ 
....................           0x3C,0x40,0x3C, /* V */ 
....................           0x7C,0x20,0x7C, /* W */ 
....................           0x6C,0x10,0x6C, /* X */ 
....................           0x1C,0x60,0x1C, /* Y */ 
....................           0x64,0x54,0x4C, /* Z */ 
....................           0x7C,0x44,0x00, /* [ */ 
....................           0x08,0x10,0x20, /* \ */ 
....................           0x44,0x7C,0x00, /* ] */ 
....................           0x08,0x04,0x08, /* ^ */ 
....................           0x80,0x80,0x80, /* _ */ 
....................           0x04,0x08,0x00 /* `   0x60 */ 
.................... }; 
....................  
.................... char const Fuente_7_8 [685]={   /* System 7x8 (char #32 to #128) */ 
....................  
....................           0,   0,   0,   0,   0,   0,   0, //' ' 
....................           0,   6,  95,  95,   6,   0,   0, //'!' 
....................           0,   7,   7,   0,   7,   7,   0, //'"' 
....................          20, 127, 127,  20, 127, 127,  20, //'#' 
....................          36,  46, 107, 107,  58,  18,   0, //'$' 
....................          70, 102,  48,  24,  12, 102,  98, //'%' 
....................          48, 122,  79,  93,  55, 122,  72, //'&' 
....................           4,   7,   3,   0,   0,   0,   0, //''' 
....................           0,  28,  62,  99,  65,   0,   0, //'(' 
....................           0,  65,  99,  62,  28,   0,   0, //')' 
....................           8,  42,  62,  28,  28,  62,  42, //'*' 
....................           8,   8,  62,  62,   8,   8,   0, //'+' 
....................           0, 128, 224,  96,   0,   0,   0, //',' 
....................           8,   8,   8,   8,   8,   8,   0, //'-' 
....................           0,   0,  96,  96,   0,   0,   0, //'.' 
....................          96,  48,  24,  12,   6,   3,   1, //'/' 
....................          62, 127, 113,  89,  77, 127,  62, //'0' 
....................          64,  66, 127, 127,  64,  64,   0, //'1' 
....................          98, 115,  89,  73, 111, 102,   0, //'2' 
....................          34,  99,  73,  73, 127,  54,   0, //'3' 
....................          24,  28,  22,  83, 127, 127,  80, //'4' 
....................          39, 103,  69,  69, 125,  57,   0, //'5' 
....................          60, 126,  75,  73, 121,  48,   0, //'6' 
....................           3,   3, 113, 121,  15,   7,   0, //'7' 
....................          54, 127,  73,  73, 127,  54,   0, //'8' 
....................           6,  79,  73, 105,  63,  30,   0, //'9' 
....................           0,   0, 102, 102,   0,   0,   0, //':' 
....................           0, 128, 230, 102,   0,   0,   0, //';' 
....................           8,  28,  54,  99,  65,   0,   0, //'<' 
....................          36,  36,  36,  36,  36,  36,   0, //'=' 
....................           0,  65,  99,  54,  28,   8,   0, //'>' 
....................           2,   3,  81,  89,  15,   6,   0, //'?' 
....................          62, 127,  65,  93,  93,  31,  30, //'@' 
....................          124, 126,  19,  19, 126, 124,  0, //'A' 
....................          65, 127, 127,  73,  73, 127,  54, //'B' 
....................          28,  62,  99,  65,  65,  99,  34,  //'C' 
....................          65, 127, 127,  65,  99,  62,  28, //'D' 
....................          65, 127, 127,  73,  93,  65,  99, //'E' 
....................          65, 127, 127,  73,  29,   1,   3, //'F' 
....................          28,  62,  99,  65,  81, 115, 114, //'G' 
....................          127, 127,   8,   8, 127, 127,  0, //'H' 
....................           0,  65, 127, 127,  65,   0,   0, //'I' 
....................          48, 112,  64,  65, 127,  63,   1, //'J' 
....................          65, 127, 127,   8,  28, 119,  99, //'K' 
....................          65, 127, 127,  65,  64,  96, 112, //'L' 
....................          127, 127,  14,  28,  14, 127,127, //'M' 
....................          127, 127,   6,  12,  24, 127,127, //'N' 
....................          28,  62,  99,  65,  99,  62,  28, //'O' 
....................          65, 127, 127,  73,   9,  15,   6, //'P' 
....................          30,  63,  33, 113, 127,  94,   0, //'Q' 
....................          65, 127, 127,   9,  25, 127, 102, //'R' 
....................          38, 111,  77,  89, 115,  50,   0, //'S' 
....................           3,  65, 127, 127,  65,   3,   0, //'T' 
....................          127, 127,  64,  64, 127, 127,   0, //'U' 
....................          31,  63,  96,  96,  63,  31,   0, //'V' 
....................          127, 127,  48, 24,  48, 127, 127, //'W' 
....................          67, 103,  60,  24,  60, 103,  67, //'X' 
....................           7,  79, 120, 120,  79,   7,   0, //'Y' 
....................          71,  99, 113,  89,  77, 103, 115, //'Z' 
....................           0, 127, 127,  65,  65,   0,   0, //'[' 
....................           1,   3,   6,  12,  24,  48,  96, //'\' 
....................           0,  65,  65, 127, 127,   0,   0, //']' 
....................           8,  12,   6,   3,   6,  12,   8, //'^' 
....................          128, 128, 128, 128, 128,128, 128, //'_' 
....................           0,   0,   3,   7,   4,   0,   0, //'`' 
....................          32, 116,  84,  84,  60, 120,  64, //'a' 
....................          65, 127,  63,  72,  72, 120,  48, //'b' 
....................          56, 124,  68,  68, 108,  40,   0, //'c' 
....................          48, 120,  72,  73,  63, 127,  64, //'d' 
....................          56, 124,  84,  84,  92,  24,   0, //'e' 
....................          72, 126, 127,  73,   3,   2,   0, //'f' 
....................          56, 188, 164, 164, 252, 120,   0, //'g' 
....................          65, 127, 127,   8,   4, 124, 120, //'h' 
....................           0,  68, 125, 125,  64,   0,   0, //'i' 
....................          96, 224, 128, 128, 253, 125,   0, //'j' 
....................          65, 127, 127,  16,  56, 108,  68, //'k' 
....................           0,  65, 127, 127,  64,   0,   0, //'l' 
....................          120, 124,  28, 56,  28, 124, 120, //'m' 
....................          124, 124,  4,   4, 124, 120,   0, //'n' 
....................          56, 124,  68,  68, 124,  56,   0, //'o' 
....................          0, 252, 252, 164,   36,  60,  24, //'p' 
....................          24,  60,  36, 164, 248, 252, 132, //'q' 
....................          68, 124, 120,  76,   4,  28,  24, //'r' 
....................          72,  92,  84,  84, 116,  36,   0, //'s' 
....................           0,   4,  62, 127,  68,  36,   0, //'t' 
....................          60, 124,  64,  64,  60, 124,  64, //'u' 
....................          28,  60,  96,  96,  60,  28,   0, //'v' 
....................          60, 124, 112,  56, 112, 124,  60, //'w' 
....................          68, 108,  56,  16,  56, 108,  68, //'x' 
....................          60, 188, 160, 160, 252, 124,   0, //'y' 
....................          76, 100, 116,  92,  76, 100,   0, //'z' 
....................           8,   8,  62, 119,  65,  65,   0, //'{' 
....................           0,   0,   0, 119, 119,   0,   0, //'|' 
....................          65,  65, 119,  62,   8,   8,   0, //'}' 
....................           2,   3,   1,   3,   2,   3,   1, //'~' 
....................          255, 29, 129,129,  129, 129, 255, //'' 
....................          14, 159, 145, 177, 251,  74,   0  //'ç' 
.................... }; 
....................  
.................... char const Fuente_5_7 [490]={ 
....................                          0x00,0x00,0x00,0x00,0x00,   // 20 space 
....................                   0x00,0x00,0x5f,0x00,0x00,   // 21 ! 
....................                   0x00,0x07,0x00,0x07,0x00,   // 22 " 
....................                   0x14,0x7f,0x14,0x7f,0x14,   // 23 # 
....................                   0x24,0x2a,0x7f,0x2a,0x12,   // 24 $ 
....................                   0x23,0x13,0x08,0x64,0x62,   // 25 % 
....................                   0x36,0x49,0x55,0x22,0x50,   // 26 & 
....................                   0x00,0x05,0x03,0x00,0x00,   // 27 ' 
....................                   0x00,0x1c,0x22,0x41,0x00,   // 28 ( 
....................                   0x00,0x41,0x22,0x1c,0x00,   // 29 ) 
....................                   0x14,0x08,0x3e,0x08,0x14,   // 2a * 
....................                   0x08,0x08,0x3e,0x08,0x08,   // 2b + 
....................                   0x00,0x50,0x30,0x00,0x00,   // 2c , 
....................                   0x08,0x08,0x08,0x08,0x08,   // 2d - 
....................                   0x00,0x60,0x60,0x00,0x00,   // 2e . 
....................                   0x20,0x10,0x08,0x04,0x02,   // 2f / 
....................                   0x3e,0x51,0x49,0x45,0x3e,   // 30 0 
....................                   0x00,0x42,0x7f,0x40,0x00,   // 31 1 
....................                   0x42,0x61,0x51,0x49,0x46,   // 32 2 
....................                   0x21,0x41,0x45,0x4b,0x31,   // 33 3 
....................                   0x18,0x14,0x12,0x7f,0x10,   // 34 4 
....................                   0x27,0x45,0x45,0x45,0x39,   // 35 5 
....................                   0x3c,0x4a,0x49,0x49,0x30,   // 36 6 
....................                   0x01,0x71,0x09,0x05,0x03,   // 37 7 
....................                   0x36,0x49,0x49,0x49,0x36,   // 38 8 
....................                   0x06,0x49,0x49,0x29,0x1e,   // 39 9 
....................                   0x00,0x36,0x36,0x00,0x00,   // 3a : 
....................                   0x00,0x56,0x36,0x00,0x00,   // 3b ; 
....................                   0x08,0x14,0x22,0x41,0x00,   // 3c < 
....................                   0x14,0x14,0x14,0x14,0x14,   // 3d = 
....................                   0x00,0x41,0x22,0x14,0x08,   // 3e > 
....................                   0x02,0x01,0x51,0x09,0x06,   // 3f ? 
....................                   0x32,0x49,0x79,0x41,0x3e,   // 40 @ 
....................                   0x7e,0x11,0x11,0x11,0x7e,   // 41 A 
....................                   0x7f,0x49,0x49,0x49,0x36,   // 42 B 
....................                   0x3e,0x41,0x41,0x41,0x22,   // 43 C 
....................                   0x7f,0x41,0x41,0x22,0x1c,   // 44 D 
....................                   0x7f,0x49,0x49,0x49,0x41,   // 45 E 
....................                   0x7f,0x09,0x09,0x09,0x01,   // 46 F 
....................                   0x3e,0x41,0x49,0x49,0x7a,   // 47 G 
....................                   0x7f,0x08,0x08,0x08,0x7f,   // 48 H 
....................                   0x00,0x41,0x7f,0x41,0x00,   // 49 I 
....................                   0x20,0x40,0x41,0x3f,0x01,   // 4a J 
....................                   0x7f,0x08,0x14,0x22,0x41,   // 4b K 
....................                   0x7f,0x40,0x40,0x40,0x40,   // 4c L 
....................                   0x7f,0x02,0x0c,0x02,0x7f,   // 4d M 
....................                   0x7f,0x04,0x08,0x10,0x7f,   // 4e N 
....................                   0x3e,0x41,0x41,0x41,0x3e,   // 4f O 
....................                         0x7f,0x09,0x09,0x09,0x06,   // 50 P 
....................                   0x3e,0x41,0x51,0x21,0x5e,   // 51 Q 
....................                   0x7f,0x09,0x19,0x29,0x46,   // 52 R 
....................                   0x46,0x49,0x49,0x49,0x31,   // 53 S 
....................                   0x01,0x01,0x7f,0x01,0x01,   // 54 T 
....................                   0x3f,0x40,0x40,0x40,0x3f,   // 55 U 
....................                   0x1f,0x20,0x40,0x20,0x1f,   // 56 V 
....................                   0x3f,0x40,0x38,0x40,0x3f,   // 57 W 
....................                   0x63,0x14,0x08,0x14,0x63,   // 58 X 
....................                   0x07,0x08,0x70,0x08,0x07,   // 59 Y 
....................                   0x61,0x51,0x49,0x45,0x43,   // 5a Z 
....................                   0x00,0x7f,0x41,0x41,0x00,   // 5b [ 
....................                   0x02,0x04,0x08,0x10,0x20,   // 5c 
....................                   0x00,0x41,0x41,0x7f,0x00,   // 5d 
....................                   0x04,0x02,0x01,0x02,0x04,   // 5e 
....................                   0x40,0x40,0x40,0x40,0x40,   // 5f 
....................                   0x00,0x01,0x02,0x04,0x00,   // 60 
....................                   0x20,0x54,0x54,0x54,0x78,   // 61 a 
....................                   0x7f,0x48,0x44,0x44,0x38,   // 62 b 
....................                   0x38,0x44,0x44,0x44,0x20,   // 63 c 
....................                   0x38,0x44,0x44,0x48,0x7f,   // 64 d 
....................                   0x38,0x54,0x54,0x54,0x18,   // 65 e 
....................                   0x08,0x7e,0x09,0x01,0x02,   // 66 f 
....................                   0x0c,0x52,0x52,0x52,0x3e,   // 67 g 
....................                   0x7f,0x08,0x04,0x04,0x78,   // 68 h 
....................                   0x00,0x44,0x7d,0x40,0x00,   // 69 i 
....................                   0x20,0x40,0x44,0x3d,0x00,   // 6a j 
....................                   0x7f,0x10,0x28,0x44,0x00,   // 6b k 
....................                   0x00,0x41,0x7f,0x40,0x00,   // 6c l 
....................                   0x7c,0x04,0x18,0x04,0x78,   // 6d m 
....................                   0x7c,0x08,0x04,0x04,0x78,   // 6e n 
....................                   0x38,0x44,0x44,0x44,0x38,   // 6f o 
....................                   0x7c,0x14,0x14,0x14,0x08,   // 70 p 
....................                   0x08,0x14,0x14,0x18,0x7c,   // 71 q 
....................                   0x7c,0x08,0x04,0x04,0x08,   // 72 r 
....................                   0x48,0x54,0x54,0x54,0x20,   // 73 s 
....................                   0x04,0x3f,0x44,0x40,0x20,   // 74 t 
....................                   0x3c,0x40,0x40,0x20,0x7c,   // 75 u 
....................                   0x1c,0x20,0x40,0x20,0x1c,   // 76 v 
....................                   0x3c,0x40,0x30,0x40,0x3c,   // 77 w 
....................                   0x44,0x28,0x10,0x28,0x44,   // 78 x 
....................                   0x0c,0x50,0x50,0x50,0x3c,   // 79 y 
....................                   0x44,0x64,0x54,0x4c,0x44,   // 7a z 
....................                   0x00,0x08,0x36,0x41,0x00,   // 7b 
....................                   0x00,0x00,0x7f,0x00,0x00,   // 7c 
....................                   0x00,0x41,0x36,0x08,0x00,   // 7d 
....................                   0x10,0x08,0x08,0x10,0x08,   // 7e 
....................                   0x78,0x46,0x41,0x46,0x78,  // 7F 
....................                        0x7C,0x09,0x05,0x05,0x78,  // 80 -> ñ 
....................                        0x7E,0x05,0x09,0x11,0x7E   // 81 -> Ñ 
....................                      };   // 7f   
....................    
.................... float const senos[46] = {0,0.0348,0.0697,0.1045,0.1391,0.1736,0.2079,0.2419, 
....................                   0.2756,0.309,0.342,0.3746,0.4067,0.4383,0.4694,0.5,0.5299, 
....................                   0.5591,0.5877,0.6156,0.6427,0.6691,0.6946,0.7193,0.7431, 
....................                   0.766,0.788,0.809,0.829,0.848,0.866,0.8829,0.8987,0.9135, 
....................                   0.9271,0.9396,0.951,0.9612,0.9702,0.9781,0.9848,0.9902, 
....................                   0.9945,0.9975,0.9993,1}; 
....................  
.................... float const cosenos[46] = {1,0.9993,0.9975,0.9945,0.9902,0.9848,0.9781,0.9702, 
....................                   0.9612,0.951,0.9396,0.9271,0.9135,0.8987,0.8829,0.866, 
....................                   0.848,0.829,0.809,0.788,0.766,0.7431,0.7193,0.6946,0.6691, 
....................                   0.6427,0.6156,0.5877,0.5591,0.5299,0.5,0.4694,0.4383, 
....................                   0.4067,0.3746,0.342,0.309,0.2756,0.2419,0.2079,0.1736, 
....................                   0.1391,0.1045,0.0697,0.0348,0};   
....................    
.................... void nokia_clean_ddram(void); 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // Envía en serie todos los bits del byte pasado 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void nokia_write_dorc(int8 bytefornokia) 
.................... { 
....................    char caa; 
....................     
....................    for (caa = 0; caa < 8; caa++) 
*
2970:  MOVLB  5
2972:  CLRF   x15
2974:  MOVF   x15,W
2976:  SUBLW  07
2978:  BNC   29A2
....................    { 
....................       output_low(Pin_Nok_Sclk); 
297A:  BCF    F92.0
297C:  BCF    F89.0
....................        
....................       delay_us(2); 
297E:  MOVLW  03
2980:  MOVWF  00
2982:  DECFSZ 00,F
2984:  BRA    2982
....................              
....................       if ((bytefornokia & 0b10000000) == 0)  
2986:  MOVF   x14,W
2988:  ANDLW  80
298A:  BNZ   2992
....................       { 
....................          output_low(Pin_Nok_Sda); 
298C:  BCF    F92.1
298E:  BCF    F89.1
....................       } 
....................       else  
2990:  BRA    2996
....................       { 
....................          output_high(Pin_Nok_sda); 
2992:  BCF    F92.1
2994:  BSF    F89.1
....................       }        
....................        
....................       output_high(Pin_Nok_Sclk); 
2996:  BCF    F92.0
2998:  BSF    F89.0
....................        
....................       bytefornokia <<= 1; 
299A:  BCF    FD8.0
299C:  RLCF   x14,F
....................    } 
299E:  INCF   x15,F
29A0:  BRA    2974
.................... } 
29A2:  MOVLB  0
29A4:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // Prepara a la LCD para que guarde el byte en la RAM (para que lo muestre 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void nokia_write_data(int8 bytefornokia_data) 
.................... {    
....................    output_high(Pin_Nok_DC); 
*
29DC:  BCF    F92.2
29DE:  BSF    F89.2
....................     
....................    output_low(Pin_Nok_CS);    //chip enabled 
29E0:  BCF    F92.3
29E2:  BCF    F89.3
....................    nokia_write_dorc(bytefornokia_data);   // Rutina que manda en serie los bits 
29E4:  MOVFF  511,514
29E8:  RCALL  2970
....................    output_high(Pin_Nok_CS);   // chip disabled 
29EA:  BCF    F92.3
29EC:  BSF    F89.3
.................... } 
29EE:  RETURN 0
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // Escribe un comando en el nokia. Para los comandos se activa D/C 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void nokia_write_command(int8 bytefornokia_command) 
.................... { 
....................    output_low(Pin_Nok_DC);   // byte is a command it is read with the eight SCLK pulse 
*
29A6:  BCF    F92.2
29A8:  BCF    F89.2
....................     
....................    output_low(Pin_Nok_CS);   // chip enabled 
29AA:  BCF    F92.3
29AC:  BCF    F89.3
....................    nokia_write_dorc(bytefornokia_command); 
29AE:  MOVFF  513,514
29B2:  RCALL  2970
....................    output_high(Pin_Nok_CS);   // chip disabled 
29B4:  BCF    F92.3
29B6:  BSF    F89.3
.................... } 
29B8:  RETURN 0
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // Escribe en la LCD el caracter pasado 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void nokia_printchar(int8 caracter) 
.................... { 
....................    int8 char_row, chardata; 
....................    int16 charpos; 
....................  
....................    if (caracter == 0xF1) caracter = 0x80; 
....................    else if (caracter == 0xD1) caracter = 0x81; 
....................    else if (caracter == '\f') {nokia_clean_ddram(); return;} 
....................    else if (caracter < 0x20) return; 
....................    else if (caracter > 0x7f) return; 
....................  
....................    for (char_row = 0; char_row < 5; char_row++)    // Son 5 Bytes por caracter Por eso este bucle 
....................    {             
....................       charpos = ((int16)((caracter & 0xFF) - 0x20) * 5) + char_row; 
....................      chardata = ASCII_TABLE[charpos]; 
....................     
....................       nokia_write_data(chardata);                    // Manda el caracter 
....................    } 
....................  
....................    nokia_write_data(0x00);                           // Mandamos 1 espacio Blanco 
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // Posicionamiento en la pantalla 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void nokia_gotoxy(int8 xnokia, int8 ynokia)      // Nokia LCD 3310 Position cursor 
.................... { 
....................       nokia_write_command(0x40 | (ynokia & 0x07));   // Y axe initialisation: 0100 0yyy 
29BA:  MOVLB  5
29BC:  MOVF   x11,W
29BE:  ANDLW  07
29C0:  IORLW  40
29C2:  MOVWF  x12
29C4:  MOVWF  x13
29C6:  MOVLB  0
29C8:  RCALL  29A6
....................       nokia_write_command(0x80 | (xnokia & 0x7f));   // X axe initialisation: 1xxx xxxx 
29CA:  MOVLB  5
29CC:  MOVF   x10,W
29CE:  ANDLW  7F
29D0:  IORLW  80
29D2:  MOVWF  x12
29D4:  MOVWF  x13
29D6:  MOVLB  0
29D8:  RCALL  29A6
.................... } 
29DA:  RETURN 0
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // Limpiamos la RAM (la pantalla) 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void nokia_borra_pantalla(void) 
.................... { 
....................    int16 ddram;  //cambiar por la del rtc del tio eso 
....................  
....................    nokia_gotoxy(0,0);                  // Vamos al principio 
*
29F0:  MOVLB  5
29F2:  CLRF   x10
29F4:  CLRF   x11
29F6:  MOVLB  0
29F8:  RCALL  29BA
....................     
....................    for (ddram = 504; ddram > 0; ddram--) // bucle estableciendo cada byte a 0x00 
29FA:  MOVLW  01
29FC:  MOVLB  5
29FE:  MOVWF  x0F
2A00:  MOVLW  F8
2A02:  MOVWF  x0E
2A04:  MOVF   x0E,F
2A06:  BNZ   2A0C
2A08:  MOVF   x0F,F
2A0A:  BZ    2A1E
....................    {    
....................       nokia_write_data(0x00); 
2A0C:  CLRF   x11
2A0E:  MOVLB  0
2A10:  RCALL  29DC
....................    } 
2A12:  MOVLB  5
2A14:  MOVF   x0E,W
2A16:  BTFSC  FD8.2
2A18:  DECF   x0F,F
2A1A:  DECF   x0E,F
2A1C:  BRA    2A04
.................... } 
2A1E:  MOVLB  0
2A20:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // Vuelca la memoria de video sobre la pantalla 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void nokia_imprime_memoria(void) 
.................... { 
.................... int16 ddram;   
....................  
....................    nokia_gotoxy(0,0);                  // Vamos al principio 
*
2D96:  MOVLB  5
2D98:  CLRF   x10
2D9A:  CLRF   x11
2D9C:  MOVLB  0
2D9E:  RCALL  29BA
....................    for (ddram=0;ddram<504;ddram++) {    
2DA0:  MOVLB  5
2DA2:  CLRF   x0F
2DA4:  CLRF   x0E
2DA6:  MOVF   x0F,W
2DA8:  SUBLW  01
2DAA:  BNC   2DD6
2DAC:  BNZ   2DB4
2DAE:  MOVF   x0E,W
2DB0:  SUBLW  F7
2DB2:  BNC   2DD6
....................       nokia_write_data(MemoriaVideo[ddram]); 
2DB4:  MOVLW  26
2DB6:  ADDWF  x0E,W
2DB8:  MOVWF  FE9
2DBA:  MOVLW  00
2DBC:  ADDWFC x0F,W
2DBE:  MOVWF  FEA
2DC0:  MOVFF  FEF,510
2DC4:  MOVFF  510,511
2DC8:  MOVLB  0
2DCA:  RCALL  29DC
....................    } 
2DCC:  MOVLB  5
2DCE:  INCF   x0E,F
2DD0:  BTFSC  FD8.2
2DD2:  INCF   x0F,F
2DD4:  BRA    2DA6
.................... } 
2DD6:  MOVLB  0
2DD8:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // Vacía la memoria de video  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void nokia_borra_memoria(void) 
.................... { 
.................... int16 ddram;   
....................    for (ddram=0;ddram<504;ddram++) 
2DDA:  MOVLB  5
2DDC:  CLRF   x0F
2DDE:  CLRF   x0E
2DE0:  MOVF   x0F,W
2DE2:  SUBLW  01
2DE4:  BNC   2E04
2DE6:  BNZ   2DEE
2DE8:  MOVF   x0E,W
2DEA:  SUBLW  F7
2DEC:  BNC   2E04
....................       MemoriaVideo[ddram]=0; 
2DEE:  MOVLW  26
2DF0:  ADDWF  x0E,W
2DF2:  MOVWF  FE9
2DF4:  MOVLW  00
2DF6:  ADDWFC x0F,W
2DF8:  MOVWF  FEA
2DFA:  CLRF   FEF
2DFC:  INCF   x0E,F
2DFE:  BTFSC  FD8.2
2E00:  INCF   x0F,F
2E02:  BRA    2DE0
.................... } 
2E04:  MOVLB  0
2E06:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // Pinta un punto en la memoria  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void nokia_punto (int8 x, int8 y, int1 color) 
.................... { 
....................    int16 ddram;  
....................     
....................    ddram = x + (((int16)(y / 8) * 84)); 
*
37E6:  MOVLB  5
37E8:  RRCF   x38,W
37EA:  MOVWF  00
37EC:  RRCF   00,F
37EE:  RRCF   00,F
37F0:  MOVLW  1F
37F2:  ANDWF  00,F
37F4:  MOVF   00,W
37F6:  CLRF   x3D
37F8:  MOVWF  x3C
37FA:  MOVFF  53D,53F
37FE:  MOVWF  x3E
3800:  CLRF   x41
3802:  MOVLW  54
3804:  MOVWF  x40
3806:  MOVLB  0
3808:  CALL   2AA6
380C:  MOVF   01,W
380E:  MOVLB  5
3810:  ADDWF  x37,W
3812:  MOVWF  x3A
3814:  MOVLW  00
3816:  ADDWFC 02,W
3818:  MOVWF  x3B
....................     
....................    if (color) 
381A:  MOVF   x39,F
381C:  BZ    3866
....................        MemoriaVideo[ddram] = MemoriaVideo[ddram] | (1 << (y % 8)); 
381E:  MOVLW  26
3820:  ADDWF  x3A,W
3822:  MOVWF  01
3824:  MOVLW  00
3826:  ADDWFC x3B,W
3828:  MOVWF  03
382A:  MOVFF  01,53C
382E:  MOVWF  x3D
3830:  MOVLW  26
3832:  ADDWF  x3A,W
3834:  MOVWF  FE9
3836:  MOVLW  00
3838:  ADDWFC x3B,W
383A:  MOVWF  FEA
383C:  MOVFF  FEF,53E
3840:  MOVF   x38,W
3842:  ANDLW  07
3844:  MOVWF  01
3846:  MOVLW  01
3848:  MOVWF  00
384A:  MOVF   01,F
384C:  BZ    3856
384E:  BCF    FD8.0
3850:  RLCF   00,F
3852:  DECFSZ 01,F
3854:  BRA    384E
3856:  MOVF   00,W
3858:  IORWF  x3E,W
385A:  MOVFF  53D,FEA
385E:  MOVFF  53C,FE9
3862:  MOVWF  FEF
....................    else 
3864:  BRA    38AE
....................        MemoriaVideo[ddram] = MemoriaVideo[ddram] & (0xFF - (1 << (y % 8))); 
3866:  MOVLW  26
3868:  ADDWF  x3A,W
386A:  MOVWF  01
386C:  MOVLW  00
386E:  ADDWFC x3B,W
3870:  MOVWF  03
3872:  MOVFF  01,53C
3876:  MOVWF  x3D
3878:  MOVLW  26
387A:  ADDWF  x3A,W
387C:  MOVWF  FE9
387E:  MOVLW  00
3880:  ADDWFC x3B,W
3882:  MOVWF  FEA
3884:  MOVFF  FEF,53E
3888:  MOVF   x38,W
388A:  ANDLW  07
388C:  MOVWF  01
388E:  MOVLW  01
3890:  MOVWF  00
3892:  MOVF   01,F
3894:  BZ    389E
3896:  BCF    FD8.0
3898:  RLCF   00,F
389A:  DECFSZ 01,F
389C:  BRA    3896
389E:  MOVF   00,W
38A0:  SUBLW  FF
38A2:  ANDWF  x3E,W
38A4:  MOVFF  53D,FEA
38A8:  MOVFF  53C,FE9
38AC:  MOVWF  FEF
.................... } 
38AE:  MOVLB  0
38B0:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // Pinta una línea en la memoria  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void nokia_linea (int8 x1, int8 y1, int8 x2, int8 y2, int1 color) 
.................... { 
....................    int8 TramoX, TramoY,MenorX,MenorY,MayorX,MayorY,TramoMax,i,xx,yy; 
....................    float OffsetX, OffsetY; 
....................  
....................    if (y1>y2) 
38B2:  MOVLB  5
38B4:  MOVF   x21,W
38B6:  SUBWF  x23,W
38B8:  BC    38D0
....................       {MenorY=y2;MayorY=y1;OffsetY=-1;} 
38BA:  MOVFF  523,528
38BE:  MOVFF  521,52A
38C2:  CLRF   x36
38C4:  CLRF   x35
38C6:  MOVLW  80
38C8:  MOVWF  x34
38CA:  MOVLW  7F
38CC:  MOVWF  x33
....................    else 
38CE:  BRA    38E2
....................       {MenorY=y1;MayorY=y2;OffsetY=1;} 
38D0:  MOVFF  521,528
38D4:  MOVFF  523,52A
38D8:  CLRF   x36
38DA:  CLRF   x35
38DC:  CLRF   x34
38DE:  MOVLW  7F
38E0:  MOVWF  x33
....................  
....................    if (y1==y2) OffsetY=0; 
38E2:  MOVF   x23,W
38E4:  SUBWF  x21,W
38E6:  BNZ   38F0
38E8:  CLRF   x36
38EA:  CLRF   x35
38EC:  CLRF   x34
38EE:  CLRF   x33
....................  
....................    if (x1>x2) 
38F0:  MOVF   x20,W
38F2:  SUBWF  x22,W
38F4:  BC    390C
....................       {MenorX=x2;MayorX=x1;OffsetX=-1;} 
38F6:  MOVFF  522,527
38FA:  MOVFF  520,529
38FE:  CLRF   x32
3900:  CLRF   x31
3902:  MOVLW  80
3904:  MOVWF  x30
3906:  MOVLW  7F
3908:  MOVWF  x2F
....................    else 
390A:  BRA    391E
....................       {MenorX=x1;MayorX=x2;OffsetX=1;} 
390C:  MOVFF  520,527
3910:  MOVFF  522,529
3914:  CLRF   x32
3916:  CLRF   x31
3918:  CLRF   x30
391A:  MOVLW  7F
391C:  MOVWF  x2F
....................  
....................    if (x1==x2) OffsetX=0; 
391E:  MOVF   x22,W
3920:  SUBWF  x20,W
3922:  BNZ   392C
3924:  CLRF   x32
3926:  CLRF   x31
3928:  CLRF   x30
392A:  CLRF   x2F
....................  
....................    TramoX = MayorX-MenorX+1; 
392C:  MOVF   x27,W
392E:  SUBWF  x29,W
3930:  ADDLW  01
3932:  MOVWF  x25
....................    TramoY = MayorY-MenorY+1; 
3934:  MOVF   x28,W
3936:  SUBWF  x2A,W
3938:  ADDLW  01
393A:  MOVWF  x26
....................  
....................    if (TramoX>TramoY) 
393C:  MOVF   x25,W
393E:  SUBWF  x26,W
3940:  BC    39D8
....................       { 
....................          OffsetY = (float)TramoY / (float)TramoX * OffsetY; 
3942:  CLRF   x49
3944:  MOVFF  526,548
3948:  MOVLB  0
394A:  RCALL  33DC
394C:  MOVFF  00,537
3950:  MOVFF  01,538
3954:  MOVFF  02,539
3958:  MOVFF  03,53A
395C:  MOVLB  5
395E:  CLRF   x49
3960:  MOVFF  525,548
3964:  MOVLB  0
3966:  RCALL  33DC
3968:  MOVFF  53A,53E
396C:  MOVFF  539,53D
3970:  MOVFF  538,53C
3974:  MOVFF  537,53B
3978:  MOVFF  03,542
397C:  MOVFF  02,541
3980:  MOVFF  01,540
3984:  MOVFF  00,53F
3988:  CALL   2F50
398C:  MOVFF  00,537
3990:  MOVFF  01,538
3994:  MOVFF  02,539
3998:  MOVFF  03,53A
399C:  MOVFF  03,54B
39A0:  MOVFF  02,54A
39A4:  MOVFF  01,549
39A8:  MOVFF  00,548
39AC:  MOVFF  536,54F
39B0:  MOVFF  535,54E
39B4:  MOVFF  534,54D
39B8:  MOVFF  533,54C
39BC:  CALL   2E5A
39C0:  MOVFF  03,536
39C4:  MOVFF  02,535
39C8:  MOVFF  01,534
39CC:  MOVFF  00,533
....................          TramoMax=TramoX; 
39D0:  MOVFF  525,52B
....................       } 
....................    else 
39D4:  BRA    3A6A
39D6:  MOVLB  5
....................       { 
....................          OffsetX = (float)TramoX / (float)TramoY * OffsetX; 
39D8:  CLRF   x49
39DA:  MOVFF  525,548
39DE:  MOVLB  0
39E0:  RCALL  33DC
39E2:  MOVFF  00,537
39E6:  MOVFF  01,538
39EA:  MOVFF  02,539
39EE:  MOVFF  03,53A
39F2:  MOVLB  5
39F4:  CLRF   x49
39F6:  MOVFF  526,548
39FA:  MOVLB  0
39FC:  RCALL  33DC
39FE:  MOVFF  53A,53E
3A02:  MOVFF  539,53D
3A06:  MOVFF  538,53C
3A0A:  MOVFF  537,53B
3A0E:  MOVFF  03,542
3A12:  MOVFF  02,541
3A16:  MOVFF  01,540
3A1A:  MOVFF  00,53F
3A1E:  CALL   2F50
3A22:  MOVFF  00,537
3A26:  MOVFF  01,538
3A2A:  MOVFF  02,539
3A2E:  MOVFF  03,53A
3A32:  MOVFF  03,54B
3A36:  MOVFF  02,54A
3A3A:  MOVFF  01,549
3A3E:  MOVFF  00,548
3A42:  MOVFF  532,54F
3A46:  MOVFF  531,54E
3A4A:  MOVFF  530,54D
3A4E:  MOVFF  52F,54C
3A52:  CALL   2E5A
3A56:  MOVFF  03,532
3A5A:  MOVFF  02,531
3A5E:  MOVFF  01,530
3A62:  MOVFF  00,52F
....................          TramoMax=TramoY; 
3A66:  MOVFF  526,52B
....................       } 
....................  
....................    for (i=0;i<TramoMax;i++) 
3A6A:  MOVLB  5
3A6C:  CLRF   x2C
3A6E:  MOVF   x2B,W
3A70:  SUBWF  x2C,W
3A72:  BTFSC  FD8.0
3A74:  BRA    3BA8
....................       { 
....................          xx=x1 + OffsetX * i; 
3A76:  CLRF   x49
3A78:  MOVFF  52C,548
3A7C:  MOVLB  0
3A7E:  RCALL  33DC
3A80:  MOVFF  532,54B
3A84:  MOVFF  531,54A
3A88:  MOVFF  530,549
3A8C:  MOVFF  52F,548
3A90:  MOVFF  03,54F
3A94:  MOVFF  02,54E
3A98:  MOVFF  01,54D
3A9C:  MOVFF  00,54C
3AA0:  CALL   2E5A
3AA4:  MOVFF  00,537
3AA8:  MOVFF  01,538
3AAC:  MOVFF  02,539
3AB0:  MOVFF  03,53A
3AB4:  MOVLB  5
3AB6:  CLRF   x49
3AB8:  MOVFF  520,548
3ABC:  MOVLB  0
3ABE:  RCALL  33DC
3AC0:  BCF    FD8.1
3AC2:  MOVFF  03,54B
3AC6:  MOVFF  02,54A
3ACA:  MOVFF  01,549
3ACE:  MOVFF  00,548
3AD2:  MOVFF  53A,54F
3AD6:  MOVFF  539,54E
3ADA:  MOVFF  538,54D
3ADE:  MOVFF  537,54C
3AE2:  CALL   30AE
3AE6:  MOVFF  03,547
3AEA:  MOVFF  02,546
3AEE:  MOVFF  01,545
3AF2:  MOVFF  00,544
3AF6:  RCALL  33A0
3AF8:  MOVFF  01,52D
....................          yy=y1 + OffsetY * i; 
3AFC:  MOVLB  5
3AFE:  CLRF   x49
3B00:  MOVFF  52C,548
3B04:  MOVLB  0
3B06:  RCALL  33DC
3B08:  MOVFF  536,54B
3B0C:  MOVFF  535,54A
3B10:  MOVFF  534,549
3B14:  MOVFF  533,548
3B18:  MOVFF  03,54F
3B1C:  MOVFF  02,54E
3B20:  MOVFF  01,54D
3B24:  MOVFF  00,54C
3B28:  CALL   2E5A
3B2C:  MOVFF  00,537
3B30:  MOVFF  01,538
3B34:  MOVFF  02,539
3B38:  MOVFF  03,53A
3B3C:  MOVLB  5
3B3E:  CLRF   x49
3B40:  MOVFF  521,548
3B44:  MOVLB  0
3B46:  RCALL  33DC
3B48:  BCF    FD8.1
3B4A:  MOVFF  03,54B
3B4E:  MOVFF  02,54A
3B52:  MOVFF  01,549
3B56:  MOVFF  00,548
3B5A:  MOVFF  53A,54F
3B5E:  MOVFF  539,54E
3B62:  MOVFF  538,54D
3B66:  MOVFF  537,54C
3B6A:  CALL   30AE
3B6E:  MOVFF  03,547
3B72:  MOVFF  02,546
3B76:  MOVFF  01,545
3B7A:  MOVFF  00,544
3B7E:  RCALL  33A0
3B80:  MOVFF  01,52E
....................          if ((xx<ANCHOPANTALLA) && (yy<ALTOPANTALLA) && (xx>=0) && (yy>=0)) 
3B84:  MOVLB  5
3B86:  MOVF   x2D,W
3B88:  SUBLW  53
3B8A:  BNC   3BA4
3B8C:  MOVF   x2E,W
3B8E:  SUBLW  2F
3B90:  BNC   3BA4
....................             nokia_punto (xx,yy, color); 
3B92:  MOVFF  52D,537
3B96:  MOVFF  52E,538
3B9A:  MOVFF  524,539
3B9E:  MOVLB  0
3BA0:  RCALL  37E6
3BA2:  MOVLB  5
....................       } 
3BA4:  INCF   x2C,F
3BA6:  BRA    3A6E
.................... } 
3BA8:  MOVLB  0
3BAA:  RETURN 0
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // Pinta un rectángulo 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void nokia_rectangulo (int8 x1, int8 y1, int8 x2, int8 y2, int1 estilo, int1 color) 
.................... { 
....................    int16 i; 
....................  
....................    nokia_linea (x1,y1,x2,y1,color); 
3BAC:  MOVFF  50E,520
3BB0:  MOVFF  50F,521
3BB4:  MOVFF  510,522
3BB8:  MOVFF  50F,523
3BBC:  MOVFF  513,524
3BC0:  RCALL  38B2
....................    nokia_linea (x1,y2,x2,y2,color); 
3BC2:  MOVFF  50E,520
3BC6:  MOVFF  511,521
3BCA:  MOVFF  510,522
3BCE:  MOVFF  511,523
3BD2:  MOVFF  513,524
3BD6:  RCALL  38B2
....................    nokia_linea (x2,y1,x2,y2,color); 
3BD8:  MOVFF  510,520
3BDC:  MOVFF  50F,521
3BE0:  MOVFF  510,522
3BE4:  MOVFF  511,523
3BE8:  MOVFF  513,524
3BEC:  RCALL  38B2
....................    nokia_linea (x1,y1,x1,y2,color); 
3BEE:  MOVFF  50E,520
3BF2:  MOVFF  50F,521
3BF6:  MOVFF  50E,522
3BFA:  MOVFF  511,523
3BFE:  MOVFF  513,524
3C02:  RCALL  38B2
....................  
....................    if (estilo) 
3C04:  MOVLB  5
3C06:  MOVF   x12,F
3C08:  BZ    3C78
....................       if (y1<y2) 
3C0A:  MOVF   x11,W
3C0C:  SUBWF  x0F,W
3C0E:  BC    3C44
....................          for (i=y1;i<y2;i++) 
3C10:  CLRF   x15
3C12:  MOVFF  50F,514
3C16:  MOVF   x15,F
3C18:  BNZ   3C42
3C1A:  MOVF   x11,W
3C1C:  SUBWF  x14,W
3C1E:  BC    3C42
....................             nokia_linea (x1,i,x2,i,color); 
3C20:  MOVFF  50E,520
3C24:  MOVFF  514,521
3C28:  MOVFF  510,522
3C2C:  MOVFF  514,523
3C30:  MOVFF  513,524
3C34:  MOVLB  0
3C36:  RCALL  38B2
3C38:  MOVLB  5
3C3A:  INCF   x14,F
3C3C:  BTFSC  FD8.2
3C3E:  INCF   x15,F
3C40:  BRA    3C16
....................       else 
3C42:  BRA    3C78
....................          for (i=y1;i>y2;i--) 
3C44:  CLRF   x15
3C46:  MOVFF  50F,514
3C4A:  MOVF   x15,F
3C4C:  BNZ   3C54
3C4E:  MOVF   x14,W
3C50:  SUBWF  x11,W
3C52:  BC    3C78
....................             nokia_linea (x1,i,x2,i,color); 
3C54:  MOVFF  50E,520
3C58:  MOVFF  514,521
3C5C:  MOVFF  510,522
3C60:  MOVFF  514,523
3C64:  MOVFF  513,524
3C68:  MOVLB  0
3C6A:  RCALL  38B2
3C6C:  MOVLB  5
3C6E:  MOVF   x14,W
3C70:  BTFSC  FD8.2
3C72:  DECF   x15,F
3C74:  DECF   x14,F
3C76:  BRA    3C4A
.................... } 
3C78:  MOVLB  0
3C7A:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // Calcula el arcocoseno de un número 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... float arcocoseno(int8 perimetro, int8 radio) 
.................... { 
3C7C:  MOVLW  2D
3C7E:  MOVLB  5
3C80:  MOVWF  x1F
....................    char j = 45; 
....................     
....................    while ((j > 0) && ((senos[j] * (float)radio) >= perimetro)) 
....................    { 
3C82:  MOVF   x1F,F
3C84:  BZ    3D3C
3C86:  MOVF   x1F,W
3C88:  MULLW  04
3C8A:  MOVF   FF3,W
3C8C:  CLRF   03
3C8E:  MOVLB  0
3C90:  CALL   2590
3C94:  MOVWF  00
3C96:  TBLRD*+
3C98:  MOVFF  FF5,01
3C9C:  TBLRD*+
3C9E:  MOVFF  FF5,02
3CA2:  TBLRD*+
3CA4:  MOVFF  FF5,03
3CA8:  MOVFF  FE8,520
3CAC:  MOVFF  01,521
3CB0:  MOVFF  02,522
3CB4:  MOVFF  03,523
3CB8:  MOVLB  5
3CBA:  CLRF   x49
3CBC:  MOVFF  51E,548
3CC0:  MOVLB  0
3CC2:  CALL   33DC
3CC6:  MOVFF  523,54B
3CCA:  MOVFF  522,54A
3CCE:  MOVFF  521,549
3CD2:  MOVFF  520,548
3CD6:  MOVFF  03,54F
3CDA:  MOVFF  02,54E
3CDE:  MOVFF  01,54D
3CE2:  MOVFF  00,54C
3CE6:  CALL   2E5A
3CEA:  MOVFF  00,520
3CEE:  MOVFF  01,521
3CF2:  MOVFF  02,522
3CF6:  MOVFF  03,523
3CFA:  MOVLB  5
3CFC:  CLRF   x49
3CFE:  MOVFF  51D,548
3D02:  MOVLB  0
3D04:  CALL   33DC
3D08:  MOVFF  03,547
3D0C:  MOVFF  02,546
3D10:  MOVFF  01,545
3D14:  MOVFF  00,544
3D18:  MOVFF  523,54B
3D1C:  MOVFF  522,54A
3D20:  MOVFF  521,549
3D24:  MOVFF  520,548
3D28:  CALL   3326
3D2C:  BC    3D36
3D2E:  BTFSC  FD8.2
3D30:  BRA    3D36
3D32:  MOVLB  5
3D34:  BRA    3D3C
....................       j--; 
3D36:  MOVLB  5
3D38:  DECF   x1F,F
....................    } 
3D3A:  BRA    3C82
....................     
....................    return (cosenos[j] * (float)radio * 1.16666); // 1.16666 es el factor de correción de la pantalla 
3D3C:  MOVF   x1F,W
3D3E:  MULLW  04
3D40:  MOVF   FF3,W
3D42:  CLRF   03
3D44:  MOVLB  0
3D46:  CALL   2658
3D4A:  MOVWF  00
3D4C:  TBLRD*+
3D4E:  MOVFF  FF5,01
3D52:  TBLRD*+
3D54:  MOVFF  FF5,02
3D58:  TBLRD*+
3D5A:  MOVFF  FF5,03
3D5E:  MOVFF  FE8,520
3D62:  MOVFF  01,521
3D66:  MOVFF  02,522
3D6A:  MOVFF  03,523
3D6E:  MOVLB  5
3D70:  CLRF   x49
3D72:  MOVFF  51E,548
3D76:  MOVLB  0
3D78:  CALL   33DC
3D7C:  MOVFF  523,54B
3D80:  MOVFF  522,54A
3D84:  MOVFF  521,549
3D88:  MOVFF  520,548
3D8C:  MOVFF  03,54F
3D90:  MOVFF  02,54E
3D94:  MOVFF  01,54D
3D98:  MOVFF  00,54C
3D9C:  CALL   2E5A
3DA0:  MOVFF  00,520
3DA4:  MOVFF  01,521
3DA8:  MOVFF  02,522
3DAC:  MOVFF  03,523
3DB0:  MOVFF  03,54B
3DB4:  MOVFF  02,54A
3DB8:  MOVFF  01,549
3DBC:  MOVFF  00,548
3DC0:  MOVLW  1D
3DC2:  MOVLB  5
3DC4:  MOVWF  x4F
3DC6:  MOVLW  55
3DC8:  MOVWF  x4E
3DCA:  MOVLW  15
3DCC:  MOVWF  x4D
3DCE:  MOVLW  7F
3DD0:  MOVWF  x4C
3DD2:  MOVLB  0
3DD4:  CALL   2E5A
.................... } 
3DD8:  GOTO   3E04 (RETURN)
....................           
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // Pinta un círculo 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void nokia_circulo(int8 x, int8 y, int8 radio, int1 estilo, int1 color) 
.................... { 
3DDC:  MOVLB  5
3DDE:  CLRF   x1B
3DE0:  CLRF   x1A
3DE2:  CLRF   x19
3DE4:  CLRF   x18
....................    int8 i; 
....................    float xx, antxx=0; 
....................  
....................    for (i = (y - radio); i <= y; i++) 
3DE6:  MOVF   x10,W
3DE8:  SUBWF  x0F,W
3DEA:  MOVWF  x13
3DEC:  MOVF   x13,W
3DEE:  SUBWF  x0F,W
3DF0:  BTFSS  FD8.0
3DF2:  BRA    4080
....................    { 
....................       xx = arcocoseno(y - i, radio); 
3DF4:  MOVF   x13,W
3DF6:  SUBWF  x0F,W
3DF8:  MOVWF  x1C
3DFA:  MOVWF  x1D
3DFC:  MOVFF  510,51E
3E00:  MOVLB  0
3E02:  BRA    3C7C
3E04:  MOVFF  03,517
3E08:  MOVFF  02,516
3E0C:  MOVFF  01,515
3E10:  MOVFF  00,514
....................           
....................       if (i > (y - radio)) 
3E14:  MOVLB  5
3E16:  MOVF   x10,W
3E18:  SUBWF  x0F,W
3E1A:  SUBWF  x13,W
3E1C:  BTFSC  FD8.2
3E1E:  BRA    3FA0
3E20:  BTFSS  FD8.0
3E22:  BRA    3FA0
....................       { 
....................          nokia_linea(x + (int8)xx, i, x + (int8)antxx, i - 1, NEGRO); 
3E24:  MOVFF  517,547
3E28:  MOVFF  516,546
3E2C:  MOVFF  515,545
3E30:  MOVFF  514,544
3E34:  MOVLB  0
3E36:  CALL   33A0
3E3A:  MOVF   01,W
3E3C:  MOVLB  5
3E3E:  ADDWF  x0E,W
3E40:  MOVWF  x1C
3E42:  MOVFF  51B,547
3E46:  MOVFF  51A,546
3E4A:  MOVFF  519,545
3E4E:  MOVFF  518,544
3E52:  MOVLB  0
3E54:  CALL   33A0
3E58:  MOVF   01,W
3E5A:  MOVLB  5
3E5C:  ADDWF  x0E,W
3E5E:  MOVWF  x1D
3E60:  MOVLW  01
3E62:  SUBWF  x13,W
3E64:  MOVWF  x1E
3E66:  MOVFF  51C,520
3E6A:  MOVFF  513,521
3E6E:  MOVFF  51D,522
3E72:  MOVWF  x23
3E74:  MOVLW  01
3E76:  MOVWF  x24
3E78:  MOVLB  0
3E7A:  RCALL  38B2
....................          nokia_linea(x - (int8)xx, i, x - (int8)antxx, i - 1, NEGRO); 
3E7C:  MOVFF  517,547
3E80:  MOVFF  516,546
3E84:  MOVFF  515,545
3E88:  MOVFF  514,544
3E8C:  CALL   33A0
3E90:  MOVF   01,W
3E92:  MOVLB  5
3E94:  SUBWF  x0E,W
3E96:  MOVWF  x1C
3E98:  MOVFF  51B,547
3E9C:  MOVFF  51A,546
3EA0:  MOVFF  519,545
3EA4:  MOVFF  518,544
3EA8:  MOVLB  0
3EAA:  CALL   33A0
3EAE:  MOVF   01,W
3EB0:  MOVLB  5
3EB2:  SUBWF  x0E,W
3EB4:  MOVWF  x1D
3EB6:  MOVLW  01
3EB8:  SUBWF  x13,W
3EBA:  MOVWF  x1E
3EBC:  MOVFF  51C,520
3EC0:  MOVFF  513,521
3EC4:  MOVFF  51D,522
3EC8:  MOVWF  x23
3ECA:  MOVLW  01
3ECC:  MOVWF  x24
3ECE:  MOVLB  0
3ED0:  RCALL  38B2
....................          nokia_linea(x + (int8)xx, 2 * y - 1 - i, x + (int8)antxx, 2 * y - i, NEGRO); 
3ED2:  MOVFF  517,547
3ED6:  MOVFF  516,546
3EDA:  MOVFF  515,545
3EDE:  MOVFF  514,544
3EE2:  CALL   33A0
3EE6:  MOVF   01,W
3EE8:  MOVLB  5
3EEA:  ADDWF  x0E,W
3EEC:  MOVWF  x1C
3EEE:  BCF    FD8.0
3EF0:  RLCF   x0F,W
3EF2:  ADDLW  FF
3EF4:  BSF    FD8.0
3EF6:  SUBFWB x13,W
3EF8:  MOVWF  x1D
3EFA:  MOVFF  51B,547
3EFE:  MOVFF  51A,546
3F02:  MOVFF  519,545
3F06:  MOVFF  518,544
3F0A:  MOVLB  0
3F0C:  CALL   33A0
3F10:  MOVF   01,W
3F12:  MOVLB  5
3F14:  ADDWF  x0E,W
3F16:  MOVWF  x1E
3F18:  BCF    FD8.0
3F1A:  RLCF   x0F,W
3F1C:  BSF    FD8.0
3F1E:  SUBFWB x13,W
3F20:  MOVWF  x1F
3F22:  MOVFF  51C,520
3F26:  MOVFF  51D,521
3F2A:  MOVFF  51E,522
3F2E:  MOVWF  x23
3F30:  MOVLW  01
3F32:  MOVWF  x24
3F34:  MOVLB  0
3F36:  RCALL  38B2
....................          nokia_linea(x - (int8)xx, 2 * y - 1 - i, x - (int8)antxx, 2 * y - i, NEGRO); 
3F38:  MOVFF  517,547
3F3C:  MOVFF  516,546
3F40:  MOVFF  515,545
3F44:  MOVFF  514,544
3F48:  CALL   33A0
3F4C:  MOVF   01,W
3F4E:  MOVLB  5
3F50:  SUBWF  x0E,W
3F52:  MOVWF  x1C
3F54:  BCF    FD8.0
3F56:  RLCF   x0F,W
3F58:  ADDLW  FF
3F5A:  BSF    FD8.0
3F5C:  SUBFWB x13,W
3F5E:  MOVWF  x1D
3F60:  MOVFF  51B,547
3F64:  MOVFF  51A,546
3F68:  MOVFF  519,545
3F6C:  MOVFF  518,544
3F70:  MOVLB  0
3F72:  CALL   33A0
3F76:  MOVF   01,W
3F78:  MOVLB  5
3F7A:  SUBWF  x0E,W
3F7C:  MOVWF  x1E
3F7E:  BCF    FD8.0
3F80:  RLCF   x0F,W
3F82:  BSF    FD8.0
3F84:  SUBFWB x13,W
3F86:  MOVWF  x1F
3F88:  MOVFF  51C,520
3F8C:  MOVFF  51D,521
3F90:  MOVFF  51E,522
3F94:  MOVWF  x23
3F96:  MOVLW  01
3F98:  MOVWF  x24
3F9A:  MOVLB  0
3F9C:  RCALL  38B2
3F9E:  MOVLB  5
....................       } 
....................        
....................       if (estilo) 
3FA0:  MOVF   x11,F
3FA2:  BZ    406C
....................       { 
....................          nokia_linea(x + (int8)xx, i - 1, x - (int8)xx, i - 1, NEGRO); 
3FA4:  MOVFF  517,547
3FA8:  MOVFF  516,546
3FAC:  MOVFF  515,545
3FB0:  MOVFF  514,544
3FB4:  MOVLB  0
3FB6:  CALL   33A0
3FBA:  MOVF   01,W
3FBC:  MOVLB  5
3FBE:  ADDWF  x0E,W
3FC0:  MOVWF  x1C
3FC2:  MOVLW  01
3FC4:  SUBWF  x13,W
3FC6:  MOVWF  x1D
3FC8:  MOVFF  517,547
3FCC:  MOVFF  516,546
3FD0:  MOVFF  515,545
3FD4:  MOVFF  514,544
3FD8:  MOVLB  0
3FDA:  CALL   33A0
3FDE:  MOVF   01,W
3FE0:  MOVLB  5
3FE2:  SUBWF  x0E,W
3FE4:  MOVWF  x1E
3FE6:  MOVLW  01
3FE8:  SUBWF  x13,W
3FEA:  MOVWF  x1F
3FEC:  MOVFF  51C,520
3FF0:  MOVFF  51D,521
3FF4:  MOVFF  51E,522
3FF8:  MOVWF  x23
3FFA:  MOVLW  01
3FFC:  MOVWF  x24
3FFE:  MOVLB  0
4000:  RCALL  38B2
....................          nokia_linea(x + (int8)xx, 2 * y - 1 - i, x - (int8)xx, 2 * y - 1 - i, NEGRO); 
4002:  MOVFF  517,547
4006:  MOVFF  516,546
400A:  MOVFF  515,545
400E:  MOVFF  514,544
4012:  CALL   33A0
4016:  MOVF   01,W
4018:  MOVLB  5
401A:  ADDWF  x0E,W
401C:  MOVWF  x1C
401E:  BCF    FD8.0
4020:  RLCF   x0F,W
4022:  ADDLW  FF
4024:  BSF    FD8.0
4026:  SUBFWB x13,W
4028:  MOVWF  x1D
402A:  MOVFF  517,547
402E:  MOVFF  516,546
4032:  MOVFF  515,545
4036:  MOVFF  514,544
403A:  MOVLB  0
403C:  CALL   33A0
4040:  MOVF   01,W
4042:  MOVLB  5
4044:  SUBWF  x0E,W
4046:  MOVWF  x1E
4048:  BCF    FD8.0
404A:  RLCF   x0F,W
404C:  ADDLW  FF
404E:  BSF    FD8.0
4050:  SUBFWB x13,W
4052:  MOVWF  x1F
4054:  MOVFF  51C,520
4058:  MOVFF  51D,521
405C:  MOVFF  51E,522
4060:  MOVWF  x23
4062:  MOVLW  01
4064:  MOVWF  x24
4066:  MOVLB  0
4068:  RCALL  38B2
406A:  MOVLB  5
....................       } 
....................        
....................       antxx = xx; 
406C:  MOVFF  517,51B
4070:  MOVFF  516,51A
4074:  MOVFF  515,519
4078:  MOVFF  514,518
....................    } 
407C:  INCF   x13,F
407E:  BRA    3DEC
.................... } 
4080:  MOVLB  0
4082:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // Pinta un bitmap 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void nokia_bitmap (signed int8 x, signed int8 y, int8 *bitmap, int8 ancho, int8 alto) 
.................... { 
....................    int16 ind_bitmap, ind_memoria, xx, yy, desplazamiento; 
....................  
....................    for (yy = 0; yy < ((alto >> 3) + ((alto % 8) > 0)); yy++) 
4084:  MOVLB  5
4086:  CLRF   x1E
4088:  CLRF   x1D
408A:  RRCF   x16,W
408C:  MOVWF  x21
408E:  RRCF   x21,F
4090:  RRCF   x21,F
4092:  MOVLW  1F
4094:  ANDWF  x21,F
4096:  MOVF   x16,W
4098:  ANDLW  07
409A:  BNZ   40A0
409C:  MOVLW  00
409E:  BRA    40A2
40A0:  MOVLW  01
40A2:  ADDWF  x21,W
40A4:  MOVF   x1E,F
40A6:  BTFSS  FD8.2
40A8:  BRA    42D4
40AA:  SUBWF  x1D,W
40AC:  BTFSC  FD8.0
40AE:  BRA    42D4
....................    { 
....................       for (xx = 0; xx < ancho; xx++) 
40B0:  CLRF   x1C
40B2:  CLRF   x1B
40B4:  MOVF   x1C,F
40B6:  BTFSS  FD8.2
40B8:  BRA    42CC
40BA:  MOVF   x15,W
40BC:  SUBWF  x1B,W
40BE:  BTFSC  FD8.0
40C0:  BRA    42CC
....................       { 
....................          if (((xx + x) < 84) && ((xx + x) > 0)) 
40C2:  CLRF   03
40C4:  MOVF   x11,W
40C6:  MOVWF  00
40C8:  BTFSC  FE8.7
40CA:  DECF   03,F
40CC:  ADDWF  x1B,W
40CE:  MOVWF  x21
40D0:  MOVF   03,W
40D2:  ADDWFC x1C,W
40D4:  MOVWF  x22
40D6:  BTFSC  FE8.7
40D8:  BRA    40E8
40DA:  MOVF   x22,F
40DC:  BTFSS  FD8.2
40DE:  BRA    42C4
40E0:  MOVF   x21,W
40E2:  SUBLW  53
40E4:  BTFSS  FD8.0
40E6:  BRA    42C4
40E8:  CLRF   03
40EA:  MOVF   x11,W
40EC:  MOVWF  00
40EE:  BTFSC  FE8.7
40F0:  DECF   03,F
40F2:  ADDWF  x1B,W
40F4:  MOVWF  x21
40F6:  MOVF   03,W
40F8:  ADDWFC x1C,W
40FA:  MOVWF  x22
40FC:  BTFSC  FE8.7
40FE:  BRA    42C4
4100:  MOVF   x22,F
4102:  BNZ   410C
4104:  MOVF   x21,W
4106:  SUBLW  00
4108:  BTFSC  FD8.0
410A:  BRA    42C4
....................          { 
....................             ind_memoria = yy * 84 + xx + x + (int16)(y >> 3) * 84; 
410C:  MOVFF  51E,53F
4110:  MOVFF  51D,53E
4114:  CLRF   x41
4116:  MOVLW  54
4118:  MOVWF  x40
411A:  MOVLB  0
411C:  CALL   2AA6
4120:  MOVFF  02,522
4124:  MOVFF  01,521
4128:  MOVLB  5
412A:  MOVF   x1B,W
412C:  ADDWF  x21,F
412E:  MOVF   x1C,W
4130:  ADDWFC x22,F
4132:  CLRF   03
4134:  MOVF   x11,W
4136:  MOVWF  00
4138:  BTFSC  FE8.7
413A:  DECF   03,F
413C:  ADDWF  x21,F
413E:  MOVF   03,W
4140:  ADDWFC x22,F
4142:  RRCF   x12,W
4144:  MOVWF  00
4146:  RRCF   00,F
4148:  RRCF   00,F
414A:  MOVLW  1F
414C:  ANDWF  00,F
414E:  MOVF   00,W
4150:  CLRF   x24
4152:  MOVWF  x23
4154:  MOVFF  524,53F
4158:  MOVWF  x3E
415A:  CLRF   x41
415C:  MOVLW  54
415E:  MOVWF  x40
4160:  MOVLB  0
4162:  CALL   2AA6
4166:  MOVFF  02,03
416A:  MOVF   01,W
416C:  MOVLB  5
416E:  ADDWF  x21,W
4170:  MOVWF  01
4172:  MOVF   x22,W
4174:  ADDWFC 03,F
4176:  MOVFF  01,519
417A:  MOVFF  03,51A
....................             ind_bitmap = yy * (int16)ancho + xx; 
417E:  CLRF   03
4180:  MOVFF  515,521
4184:  MOVFF  03,522
4188:  MOVFF  51E,53F
418C:  MOVFF  51D,53E
4190:  MOVFF  03,541
4194:  MOVFF  515,540
4198:  MOVLB  0
419A:  CALL   2AA6
419E:  MOVLB  5
41A0:  MOVF   x1B,W
41A2:  ADDWF  01,W
41A4:  MOVWF  x17
41A6:  MOVF   x1C,W
41A8:  ADDWFC 02,W
41AA:  MOVWF  x18
....................             desplazamiento = y % 8; 
41AC:  MOVFF  512,521
41B0:  MOVLW  08
41B2:  MOVWF  x22
41B4:  MOVLB  0
41B6:  CALL   2AC8
41BA:  MOVF   00,W
41BC:  CLRF   03
41BE:  MOVLB  5
41C0:  MOVWF  x1F
41C2:  MOVFF  03,520
....................             MemoriaVideo[ind_memoria] = MemoriaVideo[ind_memoria] | (bitmap[ind_bitmap] << desplazamiento); 
41C6:  MOVLW  26
41C8:  ADDWF  x19,W
41CA:  MOVWF  01
41CC:  MOVLW  00
41CE:  ADDWFC x1A,W
41D0:  MOVWF  03
41D2:  MOVFF  01,521
41D6:  MOVWF  x22
41D8:  MOVLW  26
41DA:  ADDWF  x19,W
41DC:  MOVWF  FE9
41DE:  MOVLW  00
41E0:  ADDWFC x1A,W
41E2:  MOVWF  FEA
41E4:  MOVFF  FEF,523
41E8:  MOVF   x13,W
41EA:  ADDWF  x17,W
41EC:  MOVWF  FE9
41EE:  MOVF   x14,W
41F0:  ADDWFC x18,W
41F2:  MOVWF  FEA
41F4:  MOVF   FEF,W
41F6:  CLRF   03
41F8:  MOVWF  02
41FA:  MOVF   x1F,W
41FC:  MOVWF  00
41FE:  BZ    420A
4200:  BCF    FD8.0
4202:  RLCF   02,F
4204:  RLCF   03,F
4206:  DECFSZ 00,F
4208:  BRA    4200
420A:  MOVF   02,W
420C:  IORWF  x23,W
420E:  MOVFF  522,FEA
4212:  MOVFF  521,FE9
4216:  MOVWF  FEF
....................              
....................             if (desplazamiento) 
4218:  MOVF   x1F,W
421A:  IORWF  x20,W
421C:  BZ    42C4
....................             { 
....................                MemoriaVideo[ind_memoria + 84] = MemoriaVideo[ind_memoria + 84] | ((bitmap[ind_bitmap] >> (8 - desplazamiento)) & (0xFF >> (8 - desplazamiento))); 
421E:  MOVLW  54
4220:  ADDWF  x19,W
4222:  MOVWF  x21
4224:  MOVLW  00
4226:  ADDWFC x1A,W
4228:  MOVWF  x22
422A:  MOVLW  26
422C:  ADDWF  x21,W
422E:  MOVWF  01
4230:  MOVLW  00
4232:  ADDWFC x22,W
4234:  MOVWF  03
4236:  MOVFF  01,523
423A:  MOVWF  x24
423C:  MOVLW  54
423E:  ADDWF  x19,W
4240:  MOVWF  x25
4242:  MOVLW  00
4244:  ADDWFC x1A,W
4246:  MOVWF  x26
4248:  MOVLW  26
424A:  ADDWF  x25,W
424C:  MOVWF  FE9
424E:  MOVLW  00
4250:  ADDWFC x26,W
4252:  MOVWF  FEA
4254:  MOVFF  FEF,527
4258:  MOVF   x13,W
425A:  ADDWF  x17,W
425C:  MOVWF  FE9
425E:  MOVF   x14,W
4260:  ADDWFC x18,W
4262:  MOVWF  FEA
4264:  MOVFF  FEF,528
4268:  MOVLW  08
426A:  BSF    FD8.0
426C:  SUBFWB x1F,W
426E:  MOVWF  00
4270:  MOVLW  00
4272:  SUBFWB x20,W
4274:  MOVWF  03
4276:  MOVF   00,W
4278:  CLRF   x29
427A:  MOVF   00,F
427C:  BZ    4288
427E:  BCF    FD8.0
4280:  RRCF   x29,F
4282:  RRCF   x28,F
4284:  DECFSZ 00,F
4286:  BRA    427E
4288:  MOVLW  08
428A:  BSF    FD8.0
428C:  SUBFWB x1F,W
428E:  MOVWF  00
4290:  MOVLW  00
4292:  SUBFWB x20,W
4294:  MOVWF  03
4296:  MOVF   00,W
4298:  CLRF   03
429A:  MOVLW  FF
429C:  MOVWF  02
429E:  MOVF   00,F
42A0:  BZ    42AC
42A2:  BCF    FD8.0
42A4:  RRCF   03,F
42A6:  RRCF   02,F
42A8:  DECFSZ 00,F
42AA:  BRA    42A2
42AC:  MOVF   02,W
42AE:  ANDWF  x28,W
42B0:  MOVWF  00
42B2:  MOVF   03,W
42B4:  ANDWF  x29,W
42B6:  MOVF   00,W
42B8:  IORWF  x27,W
42BA:  MOVFF  524,FEA
42BE:  MOVFF  523,FE9
42C2:  MOVWF  FEF
....................             } 
....................          } 
....................       } 
42C4:  INCF   x1B,F
42C6:  BTFSC  FD8.2
42C8:  INCF   x1C,F
42CA:  BRA    40B4
....................    } 
42CC:  INCF   x1D,F
42CE:  BTFSC  FD8.2
42D0:  INCF   x1E,F
42D2:  BRA    408A
.................... } 
42D4:  MOVLB  0
42D6:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // Escribe gráficamente texto en la LCD 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void nokia_texto(signed int8 x, signed int8 y, int8 fuente, char *caracter) 
.................... { 
....................    int16 ind_bitmap, ind_memoria, xx, desplazamiento; 
....................    int8 letra, alto, ancho, EscribirByte; 
....................  
....................    if (fuente == 1) 
*
2B14:  MOVLB  5
2B16:  DECFSZ x12,W
2B18:  BRA    2B24
....................    { 
....................       ancho = 3;  
2B1A:  MOVLW  03
2B1C:  MOVWF  x1F
....................       alto = 6; 
2B1E:  MOVLW  06
2B20:  MOVWF  x1E
....................    } 
....................    else if (fuente == 2) 
2B22:  BRA    2B3C
2B24:  MOVF   x12,W
2B26:  SUBLW  02
2B28:  BNZ   2B34
....................    { 
....................       ancho = 5; 
2B2A:  MOVLW  05
2B2C:  MOVWF  x1F
....................       alto = 7; 
2B2E:  MOVLW  07
2B30:  MOVWF  x1E
....................    } 
....................    else 
2B32:  BRA    2B3C
....................    { 
....................       ancho = 7; 
2B34:  MOVLW  07
2B36:  MOVWF  x1F
....................       alto = 8; 
2B38:  MOVLW  08
2B3A:  MOVWF  x1E
....................    } 
....................  
....................    letra = *caracter; 
2B3C:  MOVFF  513,FE9
2B40:  MOVFF  514,FEA
2B44:  MOVFF  FEF,51D
....................     
....................    while (letra != 0) 
....................    { 
2B48:  MOVF   x1D,F
2B4A:  BTFSC  FD8.2
2B4C:  BRA    2D92
....................       for (xx = 0; xx < ancho; xx++) 
2B4E:  CLRF   x1A
2B50:  CLRF   x19
2B52:  MOVF   x1A,F
2B54:  BTFSS  FD8.2
2B56:  BRA    2D76
2B58:  MOVF   x1F,W
2B5A:  SUBWF  x19,W
2B5C:  BTFSC  FD8.0
2B5E:  BRA    2D76
....................       { 
....................          if (((xx + x) < 84) && ((xx + x) >= 0) && (y >= 0)&& (y <= 40)) 
2B60:  CLRF   03
2B62:  MOVF   x10,W
2B64:  MOVWF  00
2B66:  BTFSC  FE8.7
2B68:  DECF   03,F
2B6A:  ADDWF  x19,W
2B6C:  MOVWF  x21
2B6E:  MOVF   03,W
2B70:  ADDWFC x1A,W
2B72:  MOVWF  x22
2B74:  BTFSC  FE8.7
2B76:  BRA    2B86
2B78:  MOVF   x22,F
2B7A:  BTFSS  FD8.2
2B7C:  BRA    2D6E
2B7E:  MOVF   x21,W
2B80:  SUBLW  53
2B82:  BTFSS  FD8.0
2B84:  BRA    2D6E
2B86:  CLRF   03
2B88:  MOVF   x10,W
2B8A:  MOVWF  00
2B8C:  BTFSC  FE8.7
2B8E:  DECF   03,F
2B90:  ADDWF  x19,W
2B92:  MOVWF  x21
2B94:  MOVF   03,W
2B96:  ADDWFC x1A,W
2B98:  MOVWF  x22
2B9A:  BTFSC  FE8.7
2B9C:  BRA    2D6E
2B9E:  BRA    2BA0
2BA0:  BTFSC  x11.7
2BA2:  BRA    2D6E
2BA4:  BTFSC  x11.7
2BA6:  BRA    2BB0
2BA8:  MOVF   x11,W
2BAA:  SUBLW  28
2BAC:  BTFSS  FD8.0
2BAE:  BRA    2D6E
....................          { 
....................             ind_memoria = xx + x + (int16)(y >> 3) * 84; 
2BB0:  CLRF   03
2BB2:  MOVF   x10,W
2BB4:  MOVWF  00
2BB6:  BTFSC  FE8.7
2BB8:  DECF   03,F
2BBA:  ADDWF  x19,W
2BBC:  MOVWF  x21
2BBE:  MOVF   03,W
2BC0:  ADDWFC x1A,W
2BC2:  MOVWF  x22
2BC4:  RRCF   x11,W
2BC6:  MOVWF  00
2BC8:  RRCF   00,F
2BCA:  RRCF   00,F
2BCC:  MOVLW  1F
2BCE:  ANDWF  00,F
2BD0:  MOVF   00,W
2BD2:  CLRF   x24
2BD4:  MOVWF  x23
2BD6:  MOVFF  524,53F
2BDA:  MOVWF  x3E
2BDC:  CLRF   x41
2BDE:  MOVLW  54
2BE0:  MOVWF  x40
2BE2:  MOVLB  0
2BE4:  RCALL  2AA6
2BE6:  MOVFF  02,03
2BEA:  MOVF   01,W
2BEC:  MOVLB  5
2BEE:  ADDWF  x21,W
2BF0:  MOVWF  01
2BF2:  MOVF   x22,W
2BF4:  ADDWFC 03,F
2BF6:  MOVFF  01,517
2BFA:  MOVFF  03,518
....................             ind_bitmap = (int16)(letra - 0x20) * ancho + xx; 
2BFE:  MOVLW  20
2C00:  SUBWF  x1D,W
2C02:  CLRF   x22
2C04:  MOVWF  x21
2C06:  MOVFF  522,53F
2C0A:  MOVWF  x3E
2C0C:  CLRF   x41
2C0E:  MOVFF  51F,540
2C12:  MOVLB  0
2C14:  RCALL  2AA6
2C16:  MOVLB  5
2C18:  MOVF   x19,W
2C1A:  ADDWF  01,W
2C1C:  MOVWF  x15
2C1E:  MOVF   x1A,W
2C20:  ADDWFC 02,W
2C22:  MOVWF  x16
....................             desplazamiento = y % 8; 
2C24:  MOVFF  511,521
2C28:  MOVLW  08
2C2A:  MOVWF  x22
2C2C:  MOVLB  0
2C2E:  RCALL  2AC8
2C30:  MOVF   00,W
2C32:  CLRF   03
2C34:  MOVLB  5
2C36:  MOVWF  x1B
2C38:  MOVFF  03,51C
....................  
....................             if (fuente == 1) 
2C3C:  DECFSZ x12,W
2C3E:  BRA    2C54
....................             {     
....................                EscribirByte = Fuente_3_6[ind_bitmap]; 
2C40:  MOVFF  516,03
2C44:  MOVF   x15,W
2C46:  MOVLB  0
2C48:  CALL   2200
2C4C:  MOVFF  FE8,520
....................             } 
....................             else if (fuente == 2) 
2C50:  BRA    2C86
2C52:  MOVLB  5
2C54:  MOVF   x12,W
2C56:  SUBLW  02
2C58:  BNZ   2C72
....................             { 
....................                EscribirByte = Fuente_5_7[ind_bitmap]; 
2C5A:  MOVFF  516,03
2C5E:  MOVF   x15,W
2C60:  MOVFF  516,FF7
2C64:  MOVLB  0
2C66:  CALL   2008
2C6A:  MOVFF  FE8,520
....................             } 
....................             else 
2C6E:  BRA    2C86
2C70:  MOVLB  5
....................             { 
....................                EscribirByte = Fuente_7_8[ind_bitmap]; 
2C72:  MOVFF  516,03
2C76:  MOVF   x15,W
2C78:  MOVFF  516,FF7
2C7C:  MOVLB  0
2C7E:  CALL   22D4
2C82:  MOVFF  FE8,520
....................             } 
....................                     
....................             MemoriaVideo[ind_memoria] = MemoriaVideo[ind_memoria] | (EscribirByte << desplazamiento); 
2C86:  MOVLW  26
2C88:  MOVLB  5
2C8A:  ADDWF  x17,W
2C8C:  MOVWF  01
2C8E:  MOVLW  00
2C90:  ADDWFC x18,W
2C92:  MOVWF  03
2C94:  MOVFF  01,521
2C98:  MOVWF  x22
2C9A:  MOVLW  26
2C9C:  ADDWF  x17,W
2C9E:  MOVWF  FE9
2CA0:  MOVLW  00
2CA2:  ADDWFC x18,W
2CA4:  MOVWF  FEA
2CA6:  MOVFF  FEF,523
2CAA:  MOVF   x20,W
2CAC:  CLRF   03
2CAE:  MOVWF  02
2CB0:  MOVF   x1B,W
2CB2:  MOVWF  00
2CB4:  BZ    2CC0
2CB6:  BCF    FD8.0
2CB8:  RLCF   02,F
2CBA:  RLCF   03,F
2CBC:  DECFSZ 00,F
2CBE:  BRA    2CB6
2CC0:  MOVF   02,W
2CC2:  IORWF  x23,W
2CC4:  MOVFF  522,FEA
2CC8:  MOVFF  521,FE9
2CCC:  MOVWF  FEF
....................                    
....................             if (desplazamiento) 
2CCE:  MOVF   x1B,W
2CD0:  IORWF  x1C,W
2CD2:  BZ    2D6E
....................             { 
....................                MemoriaVideo[ind_memoria + 84] = MemoriaVideo[ind_memoria + 84] | ((EscribirByte >> (8 - desplazamiento)) & (0xFF >> (8 - desplazamiento)));                         
2CD4:  MOVLW  54
2CD6:  ADDWF  x17,W
2CD8:  MOVWF  x21
2CDA:  MOVLW  00
2CDC:  ADDWFC x18,W
2CDE:  MOVWF  x22
2CE0:  MOVLW  26
2CE2:  ADDWF  x21,W
2CE4:  MOVWF  01
2CE6:  MOVLW  00
2CE8:  ADDWFC x22,W
2CEA:  MOVWF  03
2CEC:  MOVFF  01,523
2CF0:  MOVWF  x24
2CF2:  MOVLW  54
2CF4:  ADDWF  x17,W
2CF6:  MOVWF  x25
2CF8:  MOVLW  00
2CFA:  ADDWFC x18,W
2CFC:  MOVWF  x26
2CFE:  MOVLW  26
2D00:  ADDWF  x25,W
2D02:  MOVWF  FE9
2D04:  MOVLW  00
2D06:  ADDWFC x26,W
2D08:  MOVWF  FEA
2D0A:  MOVFF  FEF,527
2D0E:  MOVLW  08
2D10:  BSF    FD8.0
2D12:  SUBFWB x1B,W
2D14:  MOVWF  00
2D16:  MOVLW  00
2D18:  SUBFWB x1C,W
2D1A:  MOVWF  03
2D1C:  MOVF   00,W
2D1E:  MOVFF  520,528
2D22:  CLRF   x29
2D24:  MOVF   00,F
2D26:  BZ    2D32
2D28:  BCF    FD8.0
2D2A:  RRCF   x29,F
2D2C:  RRCF   x28,F
2D2E:  DECFSZ 00,F
2D30:  BRA    2D28
2D32:  MOVLW  08
2D34:  BSF    FD8.0
2D36:  SUBFWB x1B,W
2D38:  MOVWF  00
2D3A:  MOVLW  00
2D3C:  SUBFWB x1C,W
2D3E:  MOVWF  03
2D40:  MOVF   00,W
2D42:  CLRF   03
2D44:  MOVLW  FF
2D46:  MOVWF  02
2D48:  MOVF   00,F
2D4A:  BZ    2D56
2D4C:  BCF    FD8.0
2D4E:  RRCF   03,F
2D50:  RRCF   02,F
2D52:  DECFSZ 00,F
2D54:  BRA    2D4C
2D56:  MOVF   02,W
2D58:  ANDWF  x28,W
2D5A:  MOVWF  00
2D5C:  MOVF   03,W
2D5E:  ANDWF  x29,W
2D60:  MOVF   00,W
2D62:  IORWF  x27,W
2D64:  MOVFF  524,FEA
2D68:  MOVFF  523,FE9
2D6C:  MOVWF  FEF
....................             } 
....................          } 
....................       } 
2D6E:  INCF   x19,F
2D70:  BTFSC  FD8.2
2D72:  INCF   x1A,F
2D74:  BRA    2B52
....................              
....................       caracter++; 
2D76:  INCF   x13,F
2D78:  BTFSC  FD8.2
2D7A:  INCF   x14,F
....................       letra = *caracter; 
2D7C:  MOVFF  513,FE9
2D80:  MOVFF  514,FEA
2D84:  MOVFF  FEF,51D
....................       x = x + ancho + 1; 
2D88:  MOVF   x1F,W
2D8A:  ADDWF  x10,W
2D8C:  ADDLW  01
2D8E:  MOVWF  x10
....................    } 
2D90:  BRA    2B48
.................... } 
2D92:  MOVLB  0
2D94:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // Inicialización de la pantalla 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void Lcd_init(void)  
.................... {    
....................    delay_us(200);       // Pequeño delay de seguridad 
*
2A22:  MOVLW  C8
2A24:  MOVLB  5
2A26:  MOVWF  x0E
2A28:  MOVLB  0
2A2A:  BRA    2926
....................     
....................    output_high(Pin_Nok_DC);            // Destino de Bytes -> RAM 
2A2C:  BCF    F92.2
2A2E:  BSF    F89.2
....................    output_high(Pin_Nok_CS);            // Desactivamos el Driver para que se inicialice 
2A30:  BCF    F92.3
2A32:  BSF    F89.3
....................     
....................    delay_ms(10); 
2A34:  MOVLW  0A
2A36:  MOVLB  5
2A38:  MOVWF  x0F
2A3A:  MOVLB  0
2A3C:  RCALL  2948
....................     
....................    output_low(Pin_Nok_Res);            // Y damos un pulso de reset según indica el datasheet    
2A3E:  BCF    F92.4
2A40:  BCF    F89.4
....................    delay_ms(250);         // durante 1us.   
2A42:  MOVLW  FA
2A44:  MOVLB  5
2A46:  MOVWF  x0F
2A48:  MOVLB  0
2A4A:  RCALL  2948
....................    output_high(Pin_Nok_Res); 
2A4C:  BCF    F92.4
2A4E:  BSF    F89.4
....................     
....................    nokia_write_command(0b00100001);   // Activamos los comandos extendidos 
2A50:  MOVLW  21
2A52:  MOVLB  5
2A54:  MOVWF  x13
2A56:  MOVLB  0
2A58:  RCALL  29A6
....................    nokia_write_command(0x90);   // Definimos el Vop. Establecerá la tensión interna del cristal (su contraste) 
2A5A:  MOVLW  90
2A5C:  MOVLB  5
2A5E:  MOVWF  x13
2A60:  MOVLB  0
2A62:  RCALL  29A6
....................    nokia_write_command(0x13);   // bias 13. Min 10 Max 17 
2A64:  MOVLW  13
2A66:  MOVLB  5
2A68:  MOVWF  x13
2A6A:  MOVLB  0
2A6C:  RCALL  29A6
....................    nokia_write_command(0b00100000);    // Modo horizontal, de izq. a dcha. Se incrementa la posición automáticamente 
2A6E:  MOVLW  20
2A70:  MOVLB  5
2A72:  MOVWF  x13
2A74:  MOVLB  0
2A76:  RCALL  29A6
....................    nokia_write_command(0x09);   // all on 
2A78:  MOVLW  09
2A7A:  MOVLB  5
2A7C:  MOVWF  x13
2A7E:  MOVLB  0
2A80:  RCALL  29A6
....................     
....................    delay_ms(50); 
2A82:  MOVLW  32
2A84:  MOVLB  5
2A86:  MOVWF  x0F
2A88:  MOVLB  0
2A8A:  RCALL  2948
....................     
....................    nokia_borra_pantalla();        // Limpiamos la RAM para que no haya basura en la LCD 
2A8C:  RCALL  29F0
....................     
....................    delay_ms(10); 
2A8E:  MOVLW  0A
2A90:  MOVLB  5
2A92:  MOVWF  x0F
2A94:  MOVLB  0
2A96:  RCALL  2948
....................     
....................    nokia_write_command(0b00001100);   // mod control normal change 
2A98:  MOVLW  0C
2A9A:  MOVLB  5
2A9C:  MOVWF  x13
2A9E:  MOVLB  0
2AA0:  RCALL  29A6
.................... } 
2AA2:  GOTO   468C (RETURN)
....................  
....................  
.................... char const logonokia [168]={ // 83x15 
.................... 0xFF,0xFF,0xFF,0xFF,0x1F,0x1F,0x7F,0xFE,0xFC,0xF0,0xE0,0xC0,0x00,0x00,0x00,0xFF, 
.................... 0xFF,0xFF,0xFF,0x00,0x00,0xFC,0xFE,0xFF,0xFF,0x1F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F, 
.................... 0x0F,0x1F,0xFF,0xFF,0xFE,0xFC,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xC0,0xC0,0xE0,0xF0, 
.................... 0xFC,0xFC,0x3F,0x1F,0x0F,0x07,0x03,0x01,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00, 
.................... 0x00,0x00,0x00,0xC0,0xF0,0xFC,0xFE,0x7F,0x1F,0x1F,0x7F,0xFF,0xFC,0xF0,0xC0,0x00, 
.................... 0x00,0x00,0x00,0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,0x01,0x07,0x0F,0x3F,0x7F, 
.................... 0x7E,0x7C,0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x1F,0x3F,0x7F,0x7F,0x7C,0x78,0x78,0x78, 
.................... 0x78,0x78,0x78,0x78,0x7C,0x7F,0x7F,0x3F,0x1F,0x00,0x00,0x7F,0x7F,0x7F,0x7F,0x00, 
.................... 0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7E,0x7C,0x78,0x70,0x60,0x40,0x00,0x7F,0x7F,0x7F, 
.................... 0x7F,0x00,0x00,0x70,0x7C,0x7F,0x7F,0x1F,0x0F,0x0F,0x0E,0x0E,0x0E,0x0E,0x0F,0x0F, 
.................... 0x1F,0x7F,0x7F,0x7C,0x70,0x40}; 
....................  
.................... char const logodspic [213]={ // 71x19 
.................... 0x00,0x00,0xE0,0xF0,0xF0,0xF0,0xF0,0x70,0x70,0xF8,0xFF,0xFF,0xFF,0xFF,0x1F,0x00, 
.................... 0x80,0xF0,0xF0,0xF0,0xF0,0xF0,0x30,0xF0,0xF0,0xF0,0x70,0x70,0x20,0x00,0x00,0xC0, 
.................... 0xC6,0xE7,0xE7,0xF7,0xFF,0x3F,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0x1E,0x00,0xF0, 
.................... 0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0x01,0xE0,0xFC,0xFE,0xFF,0xFF,0xFF,0x7F,0x0F,0x2F, 
.................... 0x7F,0x7F,0x7F,0x7F,0x7F,0x3E,0x08,0xE0,0xFE,0xFF,0xFF,0xFF,0xFF,0x03,0xF0,0xFF, 
.................... 0xFF,0xFF,0xFF,0x3F,0x03,0x80,0xC0,0xE7,0xEF,0xEF,0xEF,0x1F,0x9F,0xFE,0xFC,0xFC, 
.................... 0xF8,0xF8,0x00,0x00,0xE0,0xFE,0xFF,0xFF,0xFF,0xFF,0x7F,0x1F,0x1E,0x1F,0x1F,0x1F, 
.................... 0x1F,0x0F,0x0F,0x03,0xE0,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0x03,0xC0,0xFE,0xFF,0xFF, 
.................... 0xFF,0xFF,0xFF,0x0F,0xE0,0xF8,0xF8,0xF8,0xF8,0xF8,0x78,0x00,0x00,0x00,0x03,0x07, 
.................... 0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x00,0x00,0x01,0x03,0x07,0x07, 
.................... 0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x03,0x00,0x00,0x06,0x07,0x07,0x07,0x07,0x07, 
.................... 0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x07,0x07,0x07,0x07,0x07, 
.................... 0x07,0x00,0x00,0x03,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07, 
.................... 0x03,0x00,0x00,0x00,0x00}; 
....................  
.................... char const nocturno[63]={ // 63 x 7 
.................... 0x7F,0x7F,0x0F,0x1E,0x78,0x7F,0x7F,0x00,0x3C,0x7E,0x66,0x42,0x66,0x7E,0x3C,0x00, 
.................... 0x1C,0x7E,0x7E,0x42,0x42,0x42,0x00,0x00,0x02,0x0E,0x7F,0x7F,0x42,0x42,0x00,0x00, 
.................... 0x3E,0x7E,0x7C,0x40,0x40,0x7E,0x3E,0x00,0x7E,0x7E,0x06,0x02,0x02,0x02,0x00,0x00, 
.................... 0x7E,0x7E,0x0E,0x06,0x02,0x7E,0x7E,0x00,0x3C,0x7E,0x66,0x42,0x66,0x7E,0x3C}; 
....................  
.................... char const bola[8]={ //8x8 
.................... 0x3C,0x7A,0xF1,0xFB,0xFF,0xFF,0x7E,0x3C}; 
....................  
.................... // Funcion Principal 
.................... void main(void) 
.................... { 
*
42D8:  CLRF   FF8
42DA:  BCF    FD0.7
42DC:  CLRF   FEA
42DE:  CLRF   FE9
42E0:  BSF    FB8.3
42E2:  MOVLW  56
42E4:  MOVWF  FAF
42E6:  MOVLW  00
42E8:  MOVWF  FB0
42EA:  MOVLW  A6
42EC:  MOVWF  FAC
42EE:  MOVLW  90
42F0:  MOVWF  FAB
42F2:  MOVF   FC1,W
42F4:  ANDLW  C0
42F6:  IORLW  0F
42F8:  MOVWF  FC1
42FA:  MOVLW  07
42FC:  MOVWF  FB4
....................    int8 a; 
....................    int16 j, k, offset; 
....................    signed int16 l, i; 
....................     
....................    char str1[] = "Con tres tipos"; 
42FE:  MOVLW  43
4300:  MOVLB  2
4302:  MOVWF  x29
4304:  MOVLW  6F
4306:  MOVWF  x2A
4308:  MOVLW  6E
430A:  MOVWF  x2B
430C:  MOVLW  20
430E:  MOVWF  x2C
4310:  MOVLW  74
4312:  MOVWF  x2D
4314:  MOVLW  72
4316:  MOVWF  x2E
4318:  MOVLW  65
431A:  MOVWF  x2F
431C:  MOVLW  73
431E:  MOVWF  x30
4320:  MOVLW  20
4322:  MOVWF  x31
4324:  MOVLW  74
4326:  MOVWF  x32
4328:  MOVLW  69
432A:  MOVWF  x33
432C:  MOVLW  70
432E:  MOVWF  x34
4330:  MOVLW  6F
4332:  MOVWF  x35
4334:  MOVLW  73
4336:  MOVWF  x36
4338:  CLRF   x37
....................    char str2[] = "de letra:"; 
433A:  MOVLW  64
433C:  MOVWF  x38
433E:  MOVLW  65
4340:  MOVWF  x39
4342:  MOVLW  20
4344:  MOVWF  x3A
4346:  MOVLW  6C
4348:  MOVWF  x3B
434A:  MOVLW  65
434C:  MOVWF  x3C
434E:  MOVLW  74
4350:  MOVWF  x3D
4352:  MOVLW  72
4354:  MOVWF  x3E
4356:  MOVLW  61
4358:  MOVWF  x3F
435A:  MOVLW  3A
435C:  MOVWF  x40
435E:  CLRF   x41
....................    char str3[] = "NEGRITA"; 
4360:  MOVLW  4E
4362:  MOVWF  x42
4364:  MOVLW  45
4366:  MOVWF  x43
4368:  MOVLW  47
436A:  MOVWF  x44
436C:  MOVLW  52
436E:  MOVWF  x45
4370:  MOVLW  49
4372:  MOVWF  x46
4374:  MOVLW  54
4376:  MOVWF  x47
4378:  MOVLW  41
437A:  MOVWF  x48
437C:  CLRF   x49
....................    char str4[] = "COMPRIMIDA"; 
437E:  MOVLW  43
4380:  MOVWF  x4A
4382:  MOVLW  4F
4384:  MOVWF  x4B
4386:  MOVLW  4D
4388:  MOVWF  x4C
438A:  MOVLW  50
438C:  MOVWF  x4D
438E:  MOVLW  52
4390:  MOVWF  x4E
4392:  MOVLW  49
4394:  MOVWF  x4F
4396:  MOVLW  4D
4398:  MOVWF  x50
439A:  MOVLW  49
439C:  MOVWF  x51
439E:  MOVLW  44
43A0:  MOVWF  x52
43A2:  MOVLW  41
43A4:  MOVWF  x53
43A6:  CLRF   x54
....................    char str5[] = "NORMAL"; 
43A8:  MOVLW  4E
43AA:  MOVWF  x55
43AC:  MOVLW  4F
43AE:  MOVWF  x56
43B0:  MOVLW  52
43B2:  MOVWF  x57
43B4:  MOVLW  4D
43B6:  MOVWF  x58
43B8:  MOVLW  41
43BA:  MOVWF  x59
43BC:  MOVLW  4C
43BE:  MOVWF  x5A
43C0:  CLRF   x5B
....................    char str6[] = "Funciones para"; 
43C2:  MOVLW  46
43C4:  MOVWF  x5C
43C6:  MOVLW  75
43C8:  MOVWF  x5D
43CA:  MOVLW  6E
43CC:  MOVWF  x5E
43CE:  MOVLW  63
43D0:  MOVWF  x5F
43D2:  MOVLW  69
43D4:  MOVWF  x60
43D6:  MOVLW  6F
43D8:  MOVWF  x61
43DA:  MOVLW  6E
43DC:  MOVWF  x62
43DE:  MOVLW  65
43E0:  MOVWF  x63
43E2:  MOVLW  73
43E4:  MOVWF  x64
43E6:  MOVLW  20
43E8:  MOVWF  x65
43EA:  MOVLW  70
43EC:  MOVWF  x66
43EE:  MOVLW  61
43F0:  MOVWF  x67
43F2:  MOVLW  72
43F4:  MOVWF  x68
43F6:  MOVLW  61
43F8:  MOVWF  x69
43FA:  CLRF   x6A
....................    char str7[] = "PUNTOS"; 
43FC:  MOVLW  50
43FE:  MOVWF  x6B
4400:  MOVLW  55
4402:  MOVWF  x6C
4404:  MOVLW  4E
4406:  MOVWF  x6D
4408:  MOVLW  54
440A:  MOVWF  x6E
440C:  MOVLW  4F
440E:  MOVWF  x6F
4410:  MOVLW  53
4412:  MOVWF  x70
4414:  CLRF   x71
....................    char str8[] = "LINEAS"; 
4416:  MOVLW  4C
4418:  MOVWF  x72
441A:  MOVLW  49
441C:  MOVWF  x73
441E:  MOVLW  4E
4420:  MOVWF  x74
4422:  MOVLW  45
4424:  MOVWF  x75
4426:  MOVLW  41
4428:  MOVWF  x76
442A:  MOVLW  53
442C:  MOVWF  x77
442E:  CLRF   x78
....................    char str9[] = "CUADRADOS"; 
4430:  MOVLW  43
4432:  MOVWF  x79
4434:  MOVLW  55
4436:  MOVWF  x7A
4438:  MOVLW  41
443A:  MOVWF  x7B
443C:  MOVLW  44
443E:  MOVWF  x7C
4440:  MOVLW  52
4442:  MOVWF  x7D
4444:  MOVLW  41
4446:  MOVWF  x7E
4448:  MOVLW  44
444A:  MOVWF  x7F
444C:  MOVLW  4F
444E:  MOVWF  x80
4450:  MOVLW  53
4452:  MOVWF  x81
4454:  CLRF   x82
....................    char str10[] = "CIRCULOS"; 
4456:  MOVLW  43
4458:  MOVWF  x83
445A:  MOVLW  49
445C:  MOVWF  x84
445E:  MOVLW  52
4460:  MOVWF  x85
4462:  MOVLW  43
4464:  MOVWF  x86
4466:  MOVLW  55
4468:  MOVWF  x87
446A:  MOVLW  4C
446C:  MOVWF  x88
446E:  MOVLW  4F
4470:  MOVWF  x89
4472:  MOVLW  53
4474:  MOVWF  x8A
4476:  CLRF   x8B
....................    char str11[] = "BITMAPS"; 
4478:  MOVLW  42
447A:  MOVWF  x8C
447C:  MOVLW  49
447E:  MOVWF  x8D
4480:  MOVLW  54
4482:  MOVWF  x8E
4484:  MOVLW  4D
4486:  MOVWF  x8F
4488:  MOVLW  41
448A:  MOVWF  x90
448C:  MOVLW  50
448E:  MOVWF  x91
4490:  MOVLW  53
4492:  MOVWF  x92
4494:  CLRF   x93
....................    char str12[] = "Con movimiento"; 
4496:  MOVLW  43
4498:  MOVWF  x94
449A:  MOVLW  6F
449C:  MOVWF  x95
449E:  MOVLW  6E
44A0:  MOVWF  x96
44A2:  MOVLW  20
44A4:  MOVWF  x97
44A6:  MOVLW  6D
44A8:  MOVWF  x98
44AA:  MOVLW  6F
44AC:  MOVWF  x99
44AE:  MOVLW  76
44B0:  MOVWF  x9A
44B2:  MOVLW  69
44B4:  MOVWF  x9B
44B6:  MOVLW  6D
44B8:  MOVWF  x9C
44BA:  MOVLW  69
44BC:  MOVWF  x9D
44BE:  MOVLW  65
44C0:  MOVWF  x9E
44C2:  MOVLW  6E
44C4:  MOVWF  x9F
44C6:  MOVLW  74
44C8:  MOVWF  xA0
44CA:  MOVLW  6F
44CC:  MOVWF  xA1
44CE:  CLRF   xA2
....................    char str13[] = "queda mejor ;)"; 
44D0:  MOVLW  71
44D2:  MOVWF  xA3
44D4:  MOVLW  75
44D6:  MOVWF  xA4
44D8:  MOVLW  65
44DA:  MOVWF  xA5
44DC:  MOVLW  64
44DE:  MOVWF  xA6
44E0:  MOVLW  61
44E2:  MOVWF  xA7
44E4:  MOVLW  20
44E6:  MOVWF  xA8
44E8:  MOVLW  6D
44EA:  MOVWF  xA9
44EC:  MOVLW  65
44EE:  MOVWF  xAA
44F0:  MOVLW  6A
44F2:  MOVWF  xAB
44F4:  MOVLW  6F
44F6:  MOVWF  xAC
44F8:  MOVLW  72
44FA:  MOVWF  xAD
44FC:  MOVLW  20
44FE:  MOVWF  xAE
4500:  MOVLW  3B
4502:  MOVWF  xAF
4504:  MOVLW  29
4506:  MOVWF  xB0
4508:  CLRF   xB1
....................     
....................    char str14[] = "Este ejemplo"; 
450A:  MOVLW  45
450C:  MOVWF  xB2
450E:  MOVLW  73
4510:  MOVWF  xB3
4512:  MOVLW  74
4514:  MOVWF  xB4
4516:  MOVLW  65
4518:  MOVWF  xB5
451A:  MOVLW  20
451C:  MOVWF  xB6
451E:  MOVLW  65
4520:  MOVWF  xB7
4522:  MOVLW  6A
4524:  MOVWF  xB8
4526:  MOVLW  65
4528:  MOVWF  xB9
452A:  MOVLW  6D
452C:  MOVWF  xBA
452E:  MOVLW  70
4530:  MOVWF  xBB
4532:  MOVLW  6C
4534:  MOVWF  xBC
4536:  MOVLW  6F
4538:  MOVWF  xBD
453A:  CLRF   xBE
....................    char str15[] = "esta basado en"; 
453C:  MOVLW  65
453E:  MOVWF  xBF
4540:  MOVLW  73
4542:  MOVWF  xC0
4544:  MOVLW  74
4546:  MOVWF  xC1
4548:  MOVLW  61
454A:  MOVWF  xC2
454C:  MOVLW  20
454E:  MOVWF  xC3
4550:  MOVLW  62
4552:  MOVWF  xC4
4554:  MOVLW  61
4556:  MOVWF  xC5
4558:  MOVLW  73
455A:  MOVWF  xC6
455C:  MOVLW  61
455E:  MOVWF  xC7
4560:  MOVLW  64
4562:  MOVWF  xC8
4564:  MOVLW  6F
4566:  MOVWF  xC9
4568:  MOVLW  20
456A:  MOVWF  xCA
456C:  MOVLW  65
456E:  MOVWF  xCB
4570:  MOVLW  6E
4572:  MOVWF  xCC
4574:  CLRF   xCD
....................    char str16[] = "las funciones"; 
4576:  MOVLW  6C
4578:  MOVWF  xCE
457A:  MOVLW  61
457C:  MOVWF  xCF
457E:  MOVLW  73
4580:  MOVWF  xD0
4582:  MOVLW  20
4584:  MOVWF  xD1
4586:  MOVLW  66
4588:  MOVWF  xD2
458A:  MOVLW  75
458C:  MOVWF  xD3
458E:  MOVLW  6E
4590:  MOVWF  xD4
4592:  MOVLW  63
4594:  MOVWF  xD5
4596:  MOVLW  69
4598:  MOVWF  xD6
459A:  MOVLW  6F
459C:  MOVWF  xD7
459E:  MOVLW  6E
45A0:  MOVWF  xD8
45A2:  MOVLW  65
45A4:  MOVWF  xD9
45A6:  MOVLW  73
45A8:  MOVWF  xDA
45AA:  CLRF   xDB
....................    char str17[] = "de Nocturno"; 
45AC:  MOVLW  64
45AE:  MOVWF  xDC
45B0:  MOVLW  65
45B2:  MOVWF  xDD
45B4:  MOVLW  20
45B6:  MOVWF  xDE
45B8:  MOVLW  4E
45BA:  MOVWF  xDF
45BC:  MOVLW  6F
45BE:  MOVWF  xE0
45C0:  MOVLW  63
45C2:  MOVWF  xE1
45C4:  MOVLW  74
45C6:  MOVWF  xE2
45C8:  MOVLW  75
45CA:  MOVWF  xE3
45CC:  MOVLW  72
45CE:  MOVWF  xE4
45D0:  MOVLW  6E
45D2:  MOVWF  xE5
45D4:  MOVLW  6F
45D6:  MOVWF  xE6
45D8:  CLRF   xE7
....................    char str18[] = "en C30 y"; 
45DA:  MOVLW  65
45DC:  MOVWF  xE8
45DE:  MOVLW  6E
45E0:  MOVWF  xE9
45E2:  MOVLW  20
45E4:  MOVWF  xEA
45E6:  MOVLW  43
45E8:  MOVWF  xEB
45EA:  MOVLW  33
45EC:  MOVWF  xEC
45EE:  MOVLW  30
45F0:  MOVWF  xED
45F2:  MOVLW  20
45F4:  MOVWF  xEE
45F6:  MOVLW  79
45F8:  MOVWF  xEF
45FA:  CLRF   xF0
....................    char str19[] = "adapatadas al"; 
45FC:  MOVLW  61
45FE:  MOVWF  xF1
4600:  MOVLW  64
4602:  MOVWF  xF2
4604:  MOVLW  61
4606:  MOVWF  xF3
4608:  MOVLW  70
460A:  MOVWF  xF4
460C:  MOVLW  61
460E:  MOVWF  xF5
4610:  MOVLW  74
4612:  MOVWF  xF6
4614:  MOVLW  61
4616:  MOVWF  xF7
4618:  MOVLW  64
461A:  MOVWF  xF8
461C:  MOVLW  61
461E:  MOVWF  xF9
4620:  MOVLW  73
4622:  MOVWF  xFA
4624:  MOVLW  20
4626:  MOVWF  xFB
4628:  MOVLW  61
462A:  MOVWF  xFC
462C:  MOVLW  6C
462E:  MOVWF  xFD
4630:  CLRF   xFE
....................    char str20[] = "CCS"; 
4632:  MOVLW  43
4634:  MOVWF  xFF
4636:  MOVLB  3
4638:  MOVWF  x00
463A:  MOVLW  53
463C:  MOVWF  x01
463E:  CLRF   x02
....................    char str21[] = "por"; 
4640:  MOVLW  70
4642:  MOVWF  x03
4644:  MOVLW  6F
4646:  MOVWF  x04
4648:  MOVLW  72
464A:  MOVWF  x05
464C:  CLRF   x06
....................    char str22[] = "Pinguino JACSS"; 
464E:  MOVLW  50
4650:  MOVWF  x07
4652:  MOVLW  69
4654:  MOVWF  x08
4656:  MOVLW  6E
4658:  MOVWF  x09
465A:  MOVLW  67
465C:  MOVWF  x0A
465E:  MOVLW  75
4660:  MOVWF  x0B
4662:  MOVLW  69
4664:  MOVWF  x0C
4666:  MOVLW  6E
4668:  MOVWF  x0D
466A:  MOVLW  6F
466C:  MOVWF  x0E
466E:  MOVLW  20
4670:  MOVWF  x0F
4672:  MOVLW  4A
4674:  MOVWF  x10
4676:  MOVLW  41
4678:  MOVWF  x11
467A:  MOVLW  43
467C:  MOVWF  x12
467E:  MOVLW  53
4680:  MOVWF  x13
4682:  MOVWF  x14
4684:  CLRF   x15
....................     
....................    int8 Temp[504];      
....................     
....................    lcd_init();             // Inicialización LCD 
4686:  MOVLB  0
4688:  GOTO   2A22
....................    nokia_borra_pantalla();    // La limpiamos (por si acaso) 
468C:  CALL   29F0
....................     
....................    delay_ms(300);      
4690:  MOVLW  02
4692:  MOVLB  5
4694:  MOVWF  x0E
4696:  MOVLW  96
4698:  MOVWF  x0F
469A:  MOVLB  0
469C:  CALL   2948
46A0:  MOVLB  5
46A2:  DECFSZ x0E,F
46A4:  BRA    4696
....................        
....................    while(true)  
....................    {    
....................        
....................       nokia_borra_pantalla(); 
46A6:  MOVLB  0
46A8:  CALL   29F0
....................  
....................       nokia_texto(0, 0, NORMAL, str1); 
46AC:  MOVLB  5
46AE:  CLRF   x10
46B0:  CLRF   x11
46B2:  MOVLW  02
46B4:  MOVWF  x12
46B6:  MOVWF  x14
46B8:  MOVLW  29
46BA:  MOVWF  x13
46BC:  MOVLB  0
46BE:  CALL   2B14
....................       nokia_texto(0, 8, NORMAL, str2); 
46C2:  MOVLB  5
46C4:  CLRF   x10
46C6:  MOVLW  08
46C8:  MOVWF  x11
46CA:  MOVLW  02
46CC:  MOVWF  x12
46CE:  MOVWF  x14
46D0:  MOVLW  38
46D2:  MOVWF  x13
46D4:  MOVLB  0
46D6:  CALL   2B14
....................  
....................       nokia_texto(10, 18, NEGRITA, str3 ); 
46DA:  MOVLW  0A
46DC:  MOVLB  5
46DE:  MOVWF  x10
46E0:  MOVLW  12
46E2:  MOVWF  x11
46E4:  CLRF   x12
46E6:  MOVLW  02
46E8:  MOVWF  x14
46EA:  MOVLW  42
46EC:  MOVWF  x13
46EE:  MOVLB  0
46F0:  CALL   2B14
....................       nokia_texto(20, 28, COMPRIMIDA, str4); 
46F4:  MOVLW  14
46F6:  MOVLB  5
46F8:  MOVWF  x10
46FA:  MOVLW  1C
46FC:  MOVWF  x11
46FE:  MOVLW  01
4700:  MOVWF  x12
4702:  MOVLW  02
4704:  MOVWF  x14
4706:  MOVLW  4A
4708:  MOVWF  x13
470A:  MOVLB  0
470C:  CALL   2B14
....................       nokia_texto(30, 40, NORMAL, str5); 
4710:  MOVLW  1E
4712:  MOVLB  5
4714:  MOVWF  x10
4716:  MOVLW  28
4718:  MOVWF  x11
471A:  MOVLW  02
471C:  MOVWF  x12
471E:  MOVWF  x14
4720:  MOVLW  55
4722:  MOVWF  x13
4724:  MOVLB  0
4726:  CALL   2B14
....................       nokia_imprime_memoria(); 
472A:  CALL   2D96
....................    
....................       delay_ms(4000); 
472E:  MOVLW  10
4730:  MOVLB  5
4732:  MOVWF  x0E
4734:  MOVLW  FA
4736:  MOVWF  x0F
4738:  MOVLB  0
473A:  CALL   2948
473E:  MOVLB  5
4740:  DECFSZ x0E,F
4742:  BRA    4734
....................     
....................       nokia_borra_memoria(); 
4744:  MOVLB  0
4746:  CALL   2DDA
....................       nokia_texto(0, 0, NORMAL, str6); 
474A:  MOVLB  5
474C:  CLRF   x10
474E:  CLRF   x11
4750:  MOVLW  02
4752:  MOVWF  x12
4754:  MOVWF  x14
4756:  MOVLW  5C
4758:  MOVWF  x13
475A:  MOVLB  0
475C:  CALL   2B14
....................       nokia_texto(18, 8, NEGRITA, str7); //puntos 
4760:  MOVLW  12
4762:  MOVLB  5
4764:  MOVWF  x10
4766:  MOVLW  08
4768:  MOVWF  x11
476A:  CLRF   x12
476C:  MOVLW  02
476E:  MOVWF  x14
4770:  MOVLW  6B
4772:  MOVWF  x13
4774:  MOVLB  0
4776:  CALL   2B14
....................       nokia_imprime_memoria(); 
477A:  CALL   2D96
....................        
....................       delay_ms(2000); 
477E:  MOVLW  08
4780:  MOVLB  5
4782:  MOVWF  x0E
4784:  MOVLW  FA
4786:  MOVWF  x0F
4788:  MOVLB  0
478A:  CALL   2948
478E:  MOVLB  5
4790:  DECFSZ x0E,F
4792:  BRA    4784
....................     
....................       for (j = 0; j < 60; j++) 
4794:  MOVLB  2
4796:  CLRF   x20
4798:  CLRF   x1F
479A:  MOVF   x20,F
479C:  BTFSS  FD8.2
479E:  BRA    491C
47A0:  MOVF   x1F,W
47A2:  SUBLW  3B
47A4:  BTFSS  FD8.0
47A6:  BRA    491C
....................       { 
....................          for (i = 0; i < 84; i++) 
47A8:  CLRF   x28
47AA:  CLRF   x27
47AC:  BTFSC  x28.7
47AE:  BRA    47BE
47B0:  MOVF   x28,F
47B2:  BTFSS  FD8.2
47B4:  BRA    48FC
47B6:  MOVF   x27,W
47B8:  SUBLW  53
47BA:  BTFSS  FD8.0
47BC:  BRA    48FC
....................          { 
....................             nokia_punto(i, (int8)(24 + sin((i + j) * PI / 20) * 22), NEGRO); 
47BE:  MOVF   x1F,W
47C0:  ADDWF  x27,W
47C2:  MOVLB  5
47C4:  MOVWF  x0E
47C6:  MOVLB  2
47C8:  MOVF   x20,W
47CA:  ADDWFC x28,W
47CC:  MOVLB  5
47CE:  MOVWF  x0F
47D0:  MOVWF  x11
47D2:  MOVFF  50E,510
47D6:  MOVLB  0
47D8:  GOTO   2E08
47DC:  MOVFF  03,54B
47E0:  MOVFF  02,54A
47E4:  MOVFF  01,549
47E8:  MOVFF  00,548
47EC:  MOVLW  DB
47EE:  MOVLB  5
47F0:  MOVWF  x4F
47F2:  MOVLW  0F
47F4:  MOVWF  x4E
47F6:  MOVLW  49
47F8:  MOVWF  x4D
47FA:  MOVLW  80
47FC:  MOVWF  x4C
47FE:  MOVLB  0
4800:  CALL   2E5A
4804:  MOVFF  00,50E
4808:  MOVFF  01,50F
480C:  MOVFF  02,510
4810:  MOVFF  03,511
4814:  MOVFF  03,53E
4818:  MOVFF  02,53D
481C:  MOVFF  01,53C
4820:  MOVFF  00,53B
4824:  MOVLB  5
4826:  CLRF   x42
4828:  CLRF   x41
482A:  MOVLW  20
482C:  MOVWF  x40
482E:  MOVLW  83
4830:  MOVWF  x3F
4832:  MOVLB  0
4834:  CALL   2F50
4838:  MOVFF  00,50E
483C:  MOVFF  01,50F
4840:  MOVFF  02,510
4844:  MOVFF  03,511
4848:  MOVFF  03,515
484C:  MOVFF  02,514
4850:  MOVFF  01,513
4854:  MOVFF  00,512
4858:  CALL   379A
485C:  MOVFF  00,50E
4860:  MOVFF  01,50F
4864:  MOVFF  02,510
4868:  MOVFF  03,511
486C:  MOVFF  03,54B
4870:  MOVFF  02,54A
4874:  MOVFF  01,549
4878:  MOVFF  00,548
487C:  MOVLB  5
487E:  CLRF   x4F
4880:  CLRF   x4E
4882:  MOVLW  30
4884:  MOVWF  x4D
4886:  MOVLW  83
4888:  MOVWF  x4C
488A:  MOVLB  0
488C:  CALL   2E5A
4890:  MOVFF  FEA,50F
4894:  MOVFF  FE9,50E
4898:  BCF    FD8.1
489A:  MOVLB  5
489C:  CLRF   x4B
489E:  CLRF   x4A
48A0:  MOVLW  40
48A2:  MOVWF  x49
48A4:  MOVLW  83
48A6:  MOVWF  x48
48A8:  MOVFF  03,54F
48AC:  MOVFF  02,54E
48B0:  MOVFF  01,54D
48B4:  MOVFF  00,54C
48B8:  MOVLB  0
48BA:  CALL   30AE
48BE:  MOVFF  50F,FEA
48C2:  MOVFF  50E,FE9
48C6:  MOVFF  03,547
48CA:  MOVFF  02,546
48CE:  MOVFF  01,545
48D2:  MOVFF  00,544
48D6:  CALL   33A0
48DA:  MOVFF  01,510
48DE:  MOVFF  227,537
48E2:  MOVFF  01,538
48E6:  MOVLW  01
48E8:  MOVLB  5
48EA:  MOVWF  x39
48EC:  MOVLB  0
48EE:  CALL   37E6
....................          } 
48F2:  MOVLB  2
48F4:  INCF   x27,F
48F6:  BTFSC  FD8.2
48F8:  INCF   x28,F
48FA:  BRA    47AC
....................           
....................          nokia_imprime_memoria(); 
48FC:  MOVLB  0
48FE:  CALL   2D96
....................          nokia_borra_memoria(); 
4902:  CALL   2DDA
....................          delay_ms(20); 
4906:  MOVLW  14
4908:  MOVLB  5
490A:  MOVWF  x0F
490C:  MOVLB  0
490E:  CALL   2948
....................       } 
4912:  MOVLB  2
4914:  INCF   x1F,F
4916:  BTFSC  FD8.2
4918:  INCF   x20,F
491A:  BRA    479A
....................      
....................       nokia_borra_memoria(); 
491C:  MOVLB  0
491E:  CALL   2DDA
....................        
....................       nokia_texto(0,0,NORMAL,str6); 
4922:  MOVLB  5
4924:  CLRF   x10
4926:  CLRF   x11
4928:  MOVLW  02
492A:  MOVWF  x12
492C:  MOVWF  x14
492E:  MOVLW  5C
4930:  MOVWF  x13
4932:  MOVLB  0
4934:  CALL   2B14
....................       nokia_texto(18,8,NEGRITA,str8); //lineas 
4938:  MOVLW  12
493A:  MOVLB  5
493C:  MOVWF  x10
493E:  MOVLW  08
4940:  MOVWF  x11
4942:  CLRF   x12
4944:  MOVLW  02
4946:  MOVWF  x14
4948:  MOVLW  72
494A:  MOVWF  x13
494C:  MOVLB  0
494E:  CALL   2B14
....................       nokia_imprime_memoria(); 
4952:  CALL   2D96
....................     
....................       delay_ms(2000); 
4956:  MOVLW  08
4958:  MOVLB  5
495A:  MOVWF  x0E
495C:  MOVLW  FA
495E:  MOVWF  x0F
4960:  MOVLB  0
4962:  CALL   2948
4966:  MOVLB  5
4968:  DECFSZ x0E,F
496A:  BRA    495C
....................        
....................       nokia_borra_memoria(); 
496C:  MOVLB  0
496E:  CALL   2DDA
....................        
....................       for (i = 0; i < 84; i += 4)    
4972:  MOVLB  2
4974:  CLRF   x28
4976:  CLRF   x27
4978:  BTFSC  x28.7
497A:  BRA    4986
497C:  MOVF   x28,F
497E:  BNZ   49C2
4980:  MOVF   x27,W
4982:  SUBLW  53
4984:  BNC   49C2
....................       { 
....................          nokia_linea(i, 0, 83 - i, 47, NEGRO);       
4986:  MOVLW  53
4988:  BSF    FD8.0
498A:  SUBFWB x27,W
498C:  MOVLB  5
498E:  MOVWF  x0E
4990:  MOVLW  00
4992:  MOVLB  2
4994:  SUBFWB x28,W
4996:  MOVLB  5
4998:  MOVWF  x0F
499A:  MOVFF  227,520
499E:  CLRF   x21
49A0:  MOVFF  50E,522
49A4:  MOVLW  2F
49A6:  MOVWF  x23
49A8:  MOVLW  01
49AA:  MOVWF  x24
49AC:  MOVLB  0
49AE:  CALL   38B2
....................          nokia_imprime_memoria(); 
49B2:  CALL   2D96
....................       } 
49B6:  MOVLW  04
49B8:  MOVLB  2
49BA:  ADDWF  x27,F
49BC:  MOVLW  00
49BE:  ADDWFC x28,F
49C0:  BRA    4978
....................        
....................       for (i = 0; i < 47; i += 4) 
49C2:  CLRF   x28
49C4:  CLRF   x27
49C6:  BTFSC  x28.7
49C8:  BRA    49D4
49CA:  MOVF   x28,F
49CC:  BNZ   4A10
49CE:  MOVF   x27,W
49D0:  SUBLW  2E
49D2:  BNC   4A10
....................       { 
....................          nokia_linea(83, i, 0, 47 - i, NEGRO);       
49D4:  MOVLW  2F
49D6:  BSF    FD8.0
49D8:  SUBFWB x27,W
49DA:  MOVLB  5
49DC:  MOVWF  x0E
49DE:  MOVLW  00
49E0:  MOVLB  2
49E2:  SUBFWB x28,W
49E4:  MOVLB  5
49E6:  MOVWF  x0F
49E8:  MOVLW  53
49EA:  MOVWF  x20
49EC:  MOVFF  227,521
49F0:  CLRF   x22
49F2:  MOVFF  50E,523
49F6:  MOVLW  01
49F8:  MOVWF  x24
49FA:  MOVLB  0
49FC:  CALL   38B2
....................          nokia_imprime_memoria(); 
4A00:  CALL   2D96
....................       } 
4A04:  MOVLW  04
4A06:  MOVLB  2
4A08:  ADDWF  x27,F
4A0A:  MOVLW  00
4A0C:  ADDWFC x28,F
4A0E:  BRA    49C6
....................        
....................       for (i = 0; i < 84; i += 4)    
4A10:  CLRF   x28
4A12:  CLRF   x27
4A14:  BTFSC  x28.7
4A16:  BRA    4A22
4A18:  MOVF   x28,F
4A1A:  BNZ   4A5C
4A1C:  MOVF   x27,W
4A1E:  SUBLW  53
4A20:  BNC   4A5C
....................       { 
....................          nokia_linea(i, 0, 83 - i, 47, BLANCO);       
4A22:  MOVLW  53
4A24:  BSF    FD8.0
4A26:  SUBFWB x27,W
4A28:  MOVLB  5
4A2A:  MOVWF  x0E
4A2C:  MOVLW  00
4A2E:  MOVLB  2
4A30:  SUBFWB x28,W
4A32:  MOVLB  5
4A34:  MOVWF  x0F
4A36:  MOVFF  227,520
4A3A:  CLRF   x21
4A3C:  MOVFF  50E,522
4A40:  MOVLW  2F
4A42:  MOVWF  x23
4A44:  CLRF   x24
4A46:  MOVLB  0
4A48:  CALL   38B2
....................          nokia_imprime_memoria(); 
4A4C:  CALL   2D96
....................       } 
4A50:  MOVLW  04
4A52:  MOVLB  2
4A54:  ADDWF  x27,F
4A56:  MOVLW  00
4A58:  ADDWFC x28,F
4A5A:  BRA    4A14
....................        
....................       for (i = 0; i < 47; i += 4) 
4A5C:  CLRF   x28
4A5E:  CLRF   x27
4A60:  BTFSC  x28.7
4A62:  BRA    4A6E
4A64:  MOVF   x28,F
4A66:  BNZ   4AA8
4A68:  MOVF   x27,W
4A6A:  SUBLW  2E
4A6C:  BNC   4AA8
....................       { 
....................          nokia_linea(83, i, 0, 47 - i, BLANCO);       
4A6E:  MOVLW  2F
4A70:  BSF    FD8.0
4A72:  SUBFWB x27,W
4A74:  MOVLB  5
4A76:  MOVWF  x0E
4A78:  MOVLW  00
4A7A:  MOVLB  2
4A7C:  SUBFWB x28,W
4A7E:  MOVLB  5
4A80:  MOVWF  x0F
4A82:  MOVLW  53
4A84:  MOVWF  x20
4A86:  MOVFF  227,521
4A8A:  CLRF   x22
4A8C:  MOVFF  50E,523
4A90:  CLRF   x24
4A92:  MOVLB  0
4A94:  CALL   38B2
....................          nokia_imprime_memoria(); 
4A98:  CALL   2D96
....................       } 
4A9C:  MOVLW  04
4A9E:  MOVLB  2
4AA0:  ADDWF  x27,F
4AA2:  MOVLW  00
4AA4:  ADDWFC x28,F
4AA6:  BRA    4A60
....................  
....................       nokia_borra_memoria(); 
4AA8:  MOVLB  0
4AAA:  CALL   2DDA
....................     
....................       nokia_texto(0, 0, NORMAL, str6); 
4AAE:  MOVLB  5
4AB0:  CLRF   x10
4AB2:  CLRF   x11
4AB4:  MOVLW  02
4AB6:  MOVWF  x12
4AB8:  MOVWF  x14
4ABA:  MOVLW  5C
4ABC:  MOVWF  x13
4ABE:  MOVLB  0
4AC0:  CALL   2B14
....................       nokia_texto(8, 8, NEGRITA, str9);  //cuadrados 
4AC4:  MOVLW  08
4AC6:  MOVLB  5
4AC8:  MOVWF  x10
4ACA:  MOVWF  x11
4ACC:  CLRF   x12
4ACE:  MOVLW  02
4AD0:  MOVWF  x14
4AD2:  MOVLW  79
4AD4:  MOVWF  x13
4AD6:  MOVLB  0
4AD8:  CALL   2B14
....................       nokia_imprime_memoria(); 
4ADC:  CALL   2D96
....................     
....................       delay_ms(2000); 
4AE0:  MOVLW  08
4AE2:  MOVLB  5
4AE4:  MOVWF  x0E
4AE6:  MOVLW  FA
4AE8:  MOVWF  x0F
4AEA:  MOVLB  0
4AEC:  CALL   2948
4AF0:  MOVLB  5
4AF2:  DECFSZ x0E,F
4AF4:  BRA    4AE6
....................     
....................       nokia_borra_memoria(); 
4AF6:  MOVLB  0
4AF8:  CALL   2DDA
....................        
....................       nokia_rectangulo(0, 0, 25, 15, TRANSPARENTE, NEGRO);    
4AFC:  MOVLB  5
4AFE:  CLRF   x0E
4B00:  CLRF   x0F
4B02:  MOVLW  19
4B04:  MOVWF  x10
4B06:  MOVLW  0F
4B08:  MOVWF  x11
4B0A:  CLRF   x12
4B0C:  MOVLW  01
4B0E:  MOVWF  x13
4B10:  MOVLB  0
4B12:  CALL   3BAC
....................       nokia_imprime_memoria(); 
4B16:  CALL   2D96
....................       delay_ms(500); 
4B1A:  MOVLW  02
4B1C:  MOVLB  5
4B1E:  MOVWF  x0E
4B20:  MOVLW  FA
4B22:  MOVWF  x0F
4B24:  MOVLB  0
4B26:  CALL   2948
4B2A:  MOVLB  5
4B2C:  DECFSZ x0E,F
4B2E:  BRA    4B20
....................        
....................       nokia_rectangulo(10, 10, 38, 40, SOLIDO, NEGRO);    
4B30:  MOVLW  0A
4B32:  MOVWF  x0E
4B34:  MOVWF  x0F
4B36:  MOVLW  26
4B38:  MOVWF  x10
4B3A:  MOVLW  28
4B3C:  MOVWF  x11
4B3E:  MOVLW  01
4B40:  MOVWF  x12
4B42:  MOVWF  x13
4B44:  MOVLB  0
4B46:  CALL   3BAC
....................       nokia_imprime_memoria(); 
4B4A:  CALL   2D96
....................       delay_ms(500); 
4B4E:  MOVLW  02
4B50:  MOVLB  5
4B52:  MOVWF  x0E
4B54:  MOVLW  FA
4B56:  MOVWF  x0F
4B58:  MOVLB  0
4B5A:  CALL   2948
4B5E:  MOVLB  5
4B60:  DECFSZ x0E,F
4B62:  BRA    4B54
....................        
....................       nokia_rectangulo(35, 0, 80, 15, SOLIDO, NEGRO);    
4B64:  MOVLW  23
4B66:  MOVWF  x0E
4B68:  CLRF   x0F
4B6A:  MOVLW  50
4B6C:  MOVWF  x10
4B6E:  MOVLW  0F
4B70:  MOVWF  x11
4B72:  MOVLW  01
4B74:  MOVWF  x12
4B76:  MOVWF  x13
4B78:  MOVLB  0
4B7A:  CALL   3BAC
....................       nokia_imprime_memoria(); 
4B7E:  CALL   2D96
....................       delay_ms(500); 
4B82:  MOVLW  02
4B84:  MOVLB  5
4B86:  MOVWF  x0E
4B88:  MOVLW  FA
4B8A:  MOVWF  x0F
4B8C:  MOVLB  0
4B8E:  CALL   2948
4B92:  MOVLB  5
4B94:  DECFSZ x0E,F
4B96:  BRA    4B88
....................        
....................       nokia_rectangulo(83, 47, 42, 24, SOLIDO, NEGRO);    
4B98:  MOVLW  53
4B9A:  MOVWF  x0E
4B9C:  MOVLW  2F
4B9E:  MOVWF  x0F
4BA0:  MOVLW  2A
4BA2:  MOVWF  x10
4BA4:  MOVLW  18
4BA6:  MOVWF  x11
4BA8:  MOVLW  01
4BAA:  MOVWF  x12
4BAC:  MOVWF  x13
4BAE:  MOVLB  0
4BB0:  CALL   3BAC
....................       nokia_imprime_memoria(); 
4BB4:  CALL   2D96
....................       delay_ms(500); 
4BB8:  MOVLW  02
4BBA:  MOVLB  5
4BBC:  MOVWF  x0E
4BBE:  MOVLW  FA
4BC0:  MOVWF  x0F
4BC2:  MOVLB  0
4BC4:  CALL   2948
4BC8:  MOVLB  5
4BCA:  DECFSZ x0E,F
4BCC:  BRA    4BBE
....................        
....................       nokia_rectangulo(20, 10, 64, 37, TRANSPARENTE, BLANCO);    
4BCE:  MOVLW  14
4BD0:  MOVWF  x0E
4BD2:  MOVLW  0A
4BD4:  MOVWF  x0F
4BD6:  MOVLW  40
4BD8:  MOVWF  x10
4BDA:  MOVLW  25
4BDC:  MOVWF  x11
4BDE:  CLRF   x12
4BE0:  CLRF   x13
4BE2:  MOVLB  0
4BE4:  CALL   3BAC
....................       nokia_imprime_memoria(); 
4BE8:  CALL   2D96
....................       delay_ms(500); 
4BEC:  MOVLW  02
4BEE:  MOVLB  5
4BF0:  MOVWF  x0E
4BF2:  MOVLW  FA
4BF4:  MOVWF  x0F
4BF6:  MOVLB  0
4BF8:  CALL   2948
4BFC:  MOVLB  5
4BFE:  DECFSZ x0E,F
4C00:  BRA    4BF2
....................        
....................       nokia_rectangulo(32, 14, 52, 34, SOLIDO, BLANCO);    
4C02:  MOVLW  20
4C04:  MOVWF  x0E
4C06:  MOVLW  0E
4C08:  MOVWF  x0F
4C0A:  MOVLW  34
4C0C:  MOVWF  x10
4C0E:  MOVLW  22
4C10:  MOVWF  x11
4C12:  MOVLW  01
4C14:  MOVWF  x12
4C16:  CLRF   x13
4C18:  MOVLB  0
4C1A:  CALL   3BAC
....................       nokia_imprime_memoria(); 
4C1E:  CALL   2D96
....................       delay_ms(500); 
4C22:  MOVLW  02
4C24:  MOVLB  5
4C26:  MOVWF  x0E
4C28:  MOVLW  FA
4C2A:  MOVWF  x0F
4C2C:  MOVLB  0
4C2E:  CALL   2948
4C32:  MOVLB  5
4C34:  DECFSZ x0E,F
4C36:  BRA    4C28
....................        
....................       nokia_rectangulo(37, 19, 47, 29, TRANSPARENTE, NEGRO);    
4C38:  MOVLW  25
4C3A:  MOVWF  x0E
4C3C:  MOVLW  13
4C3E:  MOVWF  x0F
4C40:  MOVLW  2F
4C42:  MOVWF  x10
4C44:  MOVLW  1D
4C46:  MOVWF  x11
4C48:  CLRF   x12
4C4A:  MOVLW  01
4C4C:  MOVWF  x13
4C4E:  MOVLB  0
4C50:  CALL   3BAC
....................       nokia_imprime_memoria(); 
4C54:  CALL   2D96
....................       delay_ms(500); 
4C58:  MOVLW  02
4C5A:  MOVLB  5
4C5C:  MOVWF  x0E
4C5E:  MOVLW  FA
4C60:  MOVWF  x0F
4C62:  MOVLB  0
4C64:  CALL   2948
4C68:  MOVLB  5
4C6A:  DECFSZ x0E,F
4C6C:  BRA    4C5E
....................  
....................       delay_ms(2000); 
4C6E:  MOVLW  08
4C70:  MOVWF  x0E
4C72:  MOVLW  FA
4C74:  MOVWF  x0F
4C76:  MOVLB  0
4C78:  CALL   2948
4C7C:  MOVLB  5
4C7E:  DECFSZ x0E,F
4C80:  BRA    4C72
....................  
....................       nokia_borra_memoria(); 
4C82:  MOVLB  0
4C84:  CALL   2DDA
....................  
....................       nokia_texto(0, 0, NORMAL, str6); 
4C88:  MOVLB  5
4C8A:  CLRF   x10
4C8C:  CLRF   x11
4C8E:  MOVLW  02
4C90:  MOVWF  x12
4C92:  MOVWF  x14
4C94:  MOVLW  5C
4C96:  MOVWF  x13
4C98:  MOVLB  0
4C9A:  CALL   2B14
....................       nokia_texto(10, 8, NEGRITA, str10);   //circulos 
4C9E:  MOVLW  0A
4CA0:  MOVLB  5
4CA2:  MOVWF  x10
4CA4:  MOVLW  08
4CA6:  MOVWF  x11
4CA8:  CLRF   x12
4CAA:  MOVLW  02
4CAC:  MOVWF  x14
4CAE:  MOVLW  83
4CB0:  MOVWF  x13
4CB2:  MOVLB  0
4CB4:  CALL   2B14
....................       nokia_imprime_memoria(); 
4CB8:  CALL   2D96
....................       delay_ms(2000); 
4CBC:  MOVLW  08
4CBE:  MOVLB  5
4CC0:  MOVWF  x0E
4CC2:  MOVLW  FA
4CC4:  MOVWF  x0F
4CC6:  MOVLB  0
4CC8:  CALL   2948
4CCC:  MOVLB  5
4CCE:  DECFSZ x0E,F
4CD0:  BRA    4CC2
....................       nokia_borra_memoria(); 
4CD2:  MOVLB  0
4CD4:  CALL   2DDA
....................  
....................       for (i = 4; i < 22; i += 3) 
4CD8:  MOVLB  2
4CDA:  CLRF   x28
4CDC:  MOVLW  04
4CDE:  MOVWF  x27
4CE0:  BTFSC  x28.7
4CE2:  BRA    4CEE
4CE4:  MOVF   x28,F
4CE6:  BNZ   4D2E
4CE8:  MOVF   x27,W
4CEA:  SUBLW  15
4CEC:  BNC   4D2E
....................       { 
....................          nokia_circulo(42, 24, i, TRANSPARENTE, NEGRO); 
4CEE:  MOVLW  2A
4CF0:  MOVLB  5
4CF2:  MOVWF  x0E
4CF4:  MOVLW  18
4CF6:  MOVWF  x0F
4CF8:  MOVFF  227,510
4CFC:  CLRF   x11
4CFE:  MOVLW  01
4D00:  MOVWF  x12
4D02:  MOVLB  0
4D04:  CALL   3DDC
....................          nokia_imprime_memoria(); 
4D08:  CALL   2D96
....................          delay_ms(500); 
4D0C:  MOVLW  02
4D0E:  MOVLB  5
4D10:  MOVWF  x0E
4D12:  MOVLW  FA
4D14:  MOVWF  x0F
4D16:  MOVLB  0
4D18:  CALL   2948
4D1C:  MOVLB  5
4D1E:  DECFSZ x0E,F
4D20:  BRA    4D12
....................       } 
4D22:  MOVLW  03
4D24:  MOVLB  2
4D26:  ADDWF  x27,F
4D28:  MOVLW  00
4D2A:  ADDWFC x28,F
4D2C:  BRA    4CE0
....................        
....................       nokia_circulo(62, 30, 15, SOLIDO, NEGRO); 
4D2E:  MOVLW  3E
4D30:  MOVLB  5
4D32:  MOVWF  x0E
4D34:  MOVLW  1E
4D36:  MOVWF  x0F
4D38:  MOVLW  0F
4D3A:  MOVWF  x10
4D3C:  MOVLW  01
4D3E:  MOVWF  x11
4D40:  MOVWF  x12
4D42:  MOVLB  0
4D44:  CALL   3DDC
....................       nokia_imprime_memoria(); 
4D48:  CALL   2D96
....................       delay_ms(500); 
4D4C:  MOVLW  02
4D4E:  MOVLB  5
4D50:  MOVWF  x0E
4D52:  MOVLW  FA
4D54:  MOVWF  x0F
4D56:  MOVLB  0
4D58:  CALL   2948
4D5C:  MOVLB  5
4D5E:  DECFSZ x0E,F
4D60:  BRA    4D52
....................        
....................       nokia_circulo(10, 10, 20, TRANSPARENTE, NEGRO); 
4D62:  MOVLW  0A
4D64:  MOVWF  x0E
4D66:  MOVWF  x0F
4D68:  MOVLW  14
4D6A:  MOVWF  x10
4D6C:  CLRF   x11
4D6E:  MOVLW  01
4D70:  MOVWF  x12
4D72:  MOVLB  0
4D74:  CALL   3DDC
....................       nokia_imprime_memoria(); 
4D78:  CALL   2D96
....................       delay_ms(500); 
4D7C:  MOVLW  02
4D7E:  MOVLB  5
4D80:  MOVWF  x0E
4D82:  MOVLW  FA
4D84:  MOVWF  x0F
4D86:  MOVLB  0
4D88:  CALL   2948
4D8C:  MOVLB  5
4D8E:  DECFSZ x0E,F
4D90:  BRA    4D82
....................        
....................       nokia_circulo(10, 10, 4, SOLIDO, NEGRO); 
4D92:  MOVLW  0A
4D94:  MOVWF  x0E
4D96:  MOVWF  x0F
4D98:  MOVLW  04
4D9A:  MOVWF  x10
4D9C:  MOVLW  01
4D9E:  MOVWF  x11
4DA0:  MOVWF  x12
4DA2:  MOVLB  0
4DA4:  CALL   3DDC
....................       nokia_imprime_memoria(); 
4DA8:  CALL   2D96
....................  
....................  
....................       delay_ms(2000);  
4DAC:  MOVLW  08
4DAE:  MOVLB  5
4DB0:  MOVWF  x0E
4DB2:  MOVLW  FA
4DB4:  MOVWF  x0F
4DB6:  MOVLB  0
4DB8:  CALL   2948
4DBC:  MOVLB  5
4DBE:  DECFSZ x0E,F
4DC0:  BRA    4DB2
....................      
....................       nokia_borra_memoria(); 
4DC2:  MOVLB  0
4DC4:  CALL   2DDA
....................       nokia_texto (0, 0, NORMAL, str6); 
4DC8:  MOVLB  5
4DCA:  CLRF   x10
4DCC:  CLRF   x11
4DCE:  MOVLW  02
4DD0:  MOVWF  x12
4DD2:  MOVWF  x14
4DD4:  MOVLW  5C
4DD6:  MOVWF  x13
4DD8:  MOVLB  0
4DDA:  CALL   2B14
....................       nokia_texto (14, 8, NEGRITA, str11);   //bitmaps 
4DDE:  MOVLW  0E
4DE0:  MOVLB  5
4DE2:  MOVWF  x10
4DE4:  MOVLW  08
4DE6:  MOVWF  x11
4DE8:  CLRF   x12
4DEA:  MOVLW  02
4DEC:  MOVWF  x14
4DEE:  MOVLW  8C
4DF0:  MOVWF  x13
4DF2:  MOVLB  0
4DF4:  CALL   2B14
....................       nokia_imprime_memoria(); 
4DF8:  CALL   2D96
....................        
....................       delay_ms(2000); 
4DFC:  MOVLW  08
4DFE:  MOVLB  5
4E00:  MOVWF  x0E
4E02:  MOVLW  FA
4E04:  MOVWF  x0F
4E06:  MOVLB  0
4E08:  CALL   2948
4E0C:  MOVLB  5
4E0E:  DECFSZ x0E,F
4E10:  BRA    4E02
....................       memcpy(Temp, logodspic, sizeof(logodspic)); 
4E12:  MOVLW  03
4E14:  MOVWF  FEA
4E16:  MOVLW  16
4E18:  MOVWF  FE9
4E1A:  MOVLW  D5
4E1C:  MOVWF  01
4E1E:  CLRF   FF7
4E20:  MOVLW  00
4E22:  MOVLB  0
4E24:  CALL   27D8
4E28:  TBLRD*-
4E2A:  TBLRD*+
4E2C:  MOVFF  FF5,FEE
4E30:  DECFSZ 01,F
4E32:  BRA    4E2A
....................       nokia_bitmap(7, 20, Temp, 71, 19); 
4E34:  MOVLW  07
4E36:  MOVLB  5
4E38:  MOVWF  x11
4E3A:  MOVLW  14
4E3C:  MOVWF  x12
4E3E:  MOVLW  03
4E40:  MOVWF  x14
4E42:  MOVLW  16
4E44:  MOVWF  x13
4E46:  MOVLW  47
4E48:  MOVWF  x15
4E4A:  MOVLW  13
4E4C:  MOVWF  x16
4E4E:  MOVLB  0
4E50:  CALL   4084
....................       nokia_imprime_memoria(); 
4E54:  CALL   2D96
....................        
....................       delay_ms(2000); 
4E58:  MOVLW  08
4E5A:  MOVLB  5
4E5C:  MOVWF  x0E
4E5E:  MOVLW  FA
4E60:  MOVWF  x0F
4E62:  MOVLB  0
4E64:  CALL   2948
4E68:  MOVLB  5
4E6A:  DECFSZ x0E,F
4E6C:  BRA    4E5E
....................  
....................       nokia_borra_memoria(); 
4E6E:  MOVLB  0
4E70:  CALL   2DDA
....................       nokia_texto(0, 0, NORMAL, str12);  //cn mvmnto 
4E74:  MOVLB  5
4E76:  CLRF   x10
4E78:  CLRF   x11
4E7A:  MOVLW  02
4E7C:  MOVWF  x12
4E7E:  MOVWF  x14
4E80:  MOVLW  94
4E82:  MOVWF  x13
4E84:  MOVLB  0
4E86:  CALL   2B14
....................       nokia_texto(0, 8, NORMAL, str13);  //qda mjor 
4E8A:  MOVLB  5
4E8C:  CLRF   x10
4E8E:  MOVLW  08
4E90:  MOVWF  x11
4E92:  MOVLW  02
4E94:  MOVWF  x12
4E96:  MOVWF  x14
4E98:  MOVLW  A3
4E9A:  MOVWF  x13
4E9C:  MOVLB  0
4E9E:  CALL   2B14
....................       nokia_imprime_memoria(); 
4EA2:  CALL   2D96
....................        
....................       delay_ms(2000); 
4EA6:  MOVLW  08
4EA8:  MOVLB  5
4EAA:  MOVWF  x0E
4EAC:  MOVLW  FA
4EAE:  MOVWF  x0F
4EB0:  MOVLB  0
4EB2:  CALL   2948
4EB6:  MOVLB  5
4EB8:  DECFSZ x0E,F
4EBA:  BRA    4EAC
....................  
....................       j = 0; 
4EBC:  MOVLB  2
4EBE:  CLRF   x20
4EC0:  CLRF   x1F
....................       offset = 1; 
4EC2:  CLRF   x24
4EC4:  MOVLW  01
4EC6:  MOVWF  x23
....................     
....................       for (i = 0; i < 29; i++) 
4EC8:  CLRF   x28
4ECA:  CLRF   x27
4ECC:  BTFSC  x28.7
4ECE:  BRA    4EDE
4ED0:  MOVF   x28,F
4ED2:  BTFSS  FD8.2
4ED4:  BRA    50EA
4ED6:  MOVF   x27,W
4ED8:  SUBLW  1C
4EDA:  BTFSS  FD8.0
4EDC:  BRA    50EA
....................       { 
....................          memcpy(Temp, logodspic, sizeof(logodspic)); 
4EDE:  MOVLW  03
4EE0:  MOVWF  FEA
4EE2:  MOVLW  16
4EE4:  MOVWF  FE9
4EE6:  MOVLW  D5
4EE8:  MOVWF  01
4EEA:  CLRF   FF7
4EEC:  MOVLW  00
4EEE:  MOVLB  0
4EF0:  CALL   27D8
4EF4:  TBLRD*-
4EF6:  TBLRD*+
4EF8:  MOVFF  FF5,FEE
4EFC:  DECFSZ 01,F
4EFE:  BRA    4EF6
....................          nokia_bitmap(7, i, Temp, 71, 19); 
4F00:  MOVLW  07
4F02:  MOVLB  5
4F04:  MOVWF  x11
4F06:  MOVFF  227,512
4F0A:  MOVLW  03
4F0C:  MOVWF  x14
4F0E:  MOVLW  16
4F10:  MOVWF  x13
4F12:  MOVLW  47
4F14:  MOVWF  x15
4F16:  MOVLW  13
4F18:  MOVWF  x16
4F1A:  MOVLB  0
4F1C:  CALL   4084
....................  
....................          memcpy(Temp, bola, sizeof(bola)); 
4F20:  MOVLW  03
4F22:  MOVWF  FEA
4F24:  MOVLW  16
4F26:  MOVWF  FE9
4F28:  MOVLW  08
4F2A:  MOVWF  01
4F2C:  CLRF   FF7
4F2E:  MOVLW  00
4F30:  CALL   290E
4F34:  TBLRD*-
4F36:  TBLRD*+
4F38:  MOVFF  FF5,FEE
4F3C:  DECFSZ 01,F
4F3E:  BRA    4F36
....................          nokia_bitmap(j, (int8)(40 - abs(sin((k++) * PI / 20) * 36)), Temp, 8, 8); 
4F40:  MOVLB  2
4F42:  MOVFF  222,03
4F46:  MOVF   x21,W
4F48:  INCF   x21,F
4F4A:  BTFSC  FD8.2
4F4C:  INCF   x22,F
4F4E:  MOVLB  5
4F50:  MOVWF  x0E
4F52:  MOVFF  03,50F
4F56:  MOVFF  03,549
4F5A:  MOVWF  x48
4F5C:  MOVLB  0
4F5E:  CALL   33DC
4F62:  MOVFF  03,54B
4F66:  MOVFF  02,54A
4F6A:  MOVFF  01,549
4F6E:  MOVFF  00,548
4F72:  MOVLW  DB
4F74:  MOVLB  5
4F76:  MOVWF  x4F
4F78:  MOVLW  0F
4F7A:  MOVWF  x4E
4F7C:  MOVLW  49
4F7E:  MOVWF  x4D
4F80:  MOVLW  80
4F82:  MOVWF  x4C
4F84:  MOVLB  0
4F86:  CALL   2E5A
4F8A:  MOVFF  00,50E
4F8E:  MOVFF  01,50F
4F92:  MOVFF  02,510
4F96:  MOVFF  03,511
4F9A:  MOVFF  03,53E
4F9E:  MOVFF  02,53D
4FA2:  MOVFF  01,53C
4FA6:  MOVFF  00,53B
4FAA:  MOVLB  5
4FAC:  CLRF   x42
4FAE:  CLRF   x41
4FB0:  MOVLW  20
4FB2:  MOVWF  x40
4FB4:  MOVLW  83
4FB6:  MOVWF  x3F
4FB8:  MOVLB  0
4FBA:  CALL   2F50
4FBE:  MOVFF  00,50E
4FC2:  MOVFF  01,50F
4FC6:  MOVFF  02,510
4FCA:  MOVFF  03,511
4FCE:  MOVFF  03,515
4FD2:  MOVFF  02,514
4FD6:  MOVFF  01,513
4FDA:  MOVFF  00,512
4FDE:  CALL   379A
4FE2:  MOVFF  00,50E
4FE6:  MOVFF  01,50F
4FEA:  MOVFF  02,510
4FEE:  MOVFF  03,511
4FF2:  MOVFF  03,54B
4FF6:  MOVFF  02,54A
4FFA:  MOVFF  01,549
4FFE:  MOVFF  00,548
5002:  MOVLB  5
5004:  CLRF   x4F
5006:  CLRF   x4E
5008:  MOVLW  10
500A:  MOVWF  x4D
500C:  MOVLW  84
500E:  MOVWF  x4C
5010:  MOVLB  0
5012:  CALL   2E5A
5016:  MOVFF  00,50E
501A:  MOVFF  01,50F
501E:  MOVFF  02,510
5022:  MOVFF  03,511
5026:  MOVFF  00,00
502A:  MOVFF  01,01
502E:  MOVFF  02,02
5032:  MOVFF  03,03
5036:  BCF    01.7
5038:  MOVFF  FEA,50F
503C:  MOVFF  FE9,50E
5040:  BSF    FD8.1
5042:  MOVLB  5
5044:  CLRF   x4B
5046:  CLRF   x4A
5048:  MOVLW  20
504A:  MOVWF  x49
504C:  MOVLW  84
504E:  MOVWF  x48
5050:  MOVFF  03,54F
5054:  MOVFF  02,54E
5058:  MOVFF  01,54D
505C:  MOVFF  00,54C
5060:  MOVLB  0
5062:  CALL   30AE
5066:  MOVFF  50F,FEA
506A:  MOVFF  50E,FE9
506E:  MOVFF  03,547
5072:  MOVFF  02,546
5076:  MOVFF  01,545
507A:  MOVFF  00,544
507E:  CALL   33A0
5082:  MOVFF  01,510
5086:  MOVFF  21F,511
508A:  MOVFF  01,512
508E:  MOVLW  03
5090:  MOVLB  5
5092:  MOVWF  x14
5094:  MOVLW  16
5096:  MOVWF  x13
5098:  MOVLW  08
509A:  MOVWF  x15
509C:  MOVWF  x16
509E:  MOVLB  0
50A0:  CALL   4084
....................           
....................          j = j + offset; 
50A4:  MOVLB  2
50A6:  MOVF   x23,W
50A8:  ADDWF  x1F,F
50AA:  MOVF   x24,W
50AC:  ADDWFC x20,F
....................           
....................          if (j > 76) 
50AE:  MOVF   x20,F
50B0:  BNZ   50B8
50B2:  MOVF   x1F,W
50B4:  SUBLW  4C
50B6:  BC    50BC
....................          {      
....................             offset =- 1; 
50B8:  SETF   x24
50BA:  SETF   x23
....................          } 
....................           
....................          if (j == 0) 
50BC:  MOVF   x1F,F
50BE:  BNZ   50CA
50C0:  MOVF   x20,F
50C2:  BNZ   50CA
....................          { 
....................             offset = 1; 
50C4:  CLRF   x24
50C6:  MOVLW  01
50C8:  MOVWF  x23
....................          } 
....................  
....................          nokia_imprime_memoria(); 
50CA:  MOVLB  0
50CC:  CALL   2D96
....................          nokia_borra_memoria(); 
50D0:  CALL   2DDA
....................           
....................          delay_ms(35); 
50D4:  MOVLW  23
50D6:  MOVLB  5
50D8:  MOVWF  x0F
50DA:  MOVLB  0
50DC:  CALL   2948
....................       } 
50E0:  MOVLB  2
50E2:  INCF   x27,F
50E4:  BTFSC  FD8.2
50E6:  INCF   x28,F
50E8:  BRA    4ECC
....................     
....................       for (i = 83; i > 0; i--) 
50EA:  CLRF   x28
50EC:  MOVLW  53
50EE:  MOVWF  x27
50F0:  BTFSC  x28.7
50F2:  BRA    534C
50F4:  MOVF   x28,F
50F6:  BNZ   5100
50F8:  MOVF   x27,W
50FA:  SUBLW  00
50FC:  BTFSC  FD8.0
50FE:  BRA    534C
....................       { 
....................          memcpy(Temp, logodspic, sizeof(logodspic)); 
5100:  MOVLW  03
5102:  MOVWF  FEA
5104:  MOVLW  16
5106:  MOVWF  FE9
5108:  MOVLW  D5
510A:  MOVWF  01
510C:  CLRF   FF7
510E:  MOVLW  00
5110:  MOVLB  0
5112:  CALL   27D8
5116:  TBLRD*-
5118:  TBLRD*+
511A:  MOVFF  FF5,FEE
511E:  DECFSZ 01,F
5120:  BRA    5118
....................          nokia_bitmap(7, 29, Temp, 71, 19); 
5122:  MOVLW  07
5124:  MOVLB  5
5126:  MOVWF  x11
5128:  MOVLW  1D
512A:  MOVWF  x12
512C:  MOVLW  03
512E:  MOVWF  x14
5130:  MOVLW  16
5132:  MOVWF  x13
5134:  MOVLW  47
5136:  MOVWF  x15
5138:  MOVLW  13
513A:  MOVWF  x16
513C:  MOVLB  0
513E:  CALL   4084
....................           
....................          memcpy(Temp, logonokia, sizeof(logonokia)); 
5142:  MOVLW  03
5144:  MOVWF  FEA
5146:  MOVLW  16
5148:  MOVWF  FE9
514A:  MOVLW  A8
514C:  MOVWF  01
514E:  CLRF   FF7
5150:  MOVLW  00
5152:  CALL   2720
5156:  TBLRD*-
5158:  TBLRD*+
515A:  MOVFF  FF5,FEE
515E:  DECFSZ 01,F
5160:  BRA    5158
....................          nokia_bitmap(i, 0, Temp, 83, 15); 
5162:  MOVFF  227,511
5166:  MOVLB  5
5168:  CLRF   x12
516A:  MOVLW  03
516C:  MOVWF  x14
516E:  MOVLW  16
5170:  MOVWF  x13
5172:  MOVLW  53
5174:  MOVWF  x15
5176:  MOVLW  0F
5178:  MOVWF  x16
517A:  MOVLB  0
517C:  CALL   4084
....................  
....................          memcpy(Temp, bola, sizeof(bola)); 
5180:  MOVLW  03
5182:  MOVWF  FEA
5184:  MOVLW  16
5186:  MOVWF  FE9
5188:  MOVLW  08
518A:  MOVWF  01
518C:  CLRF   FF7
518E:  MOVLW  00
5190:  CALL   290E
5194:  TBLRD*-
5196:  TBLRD*+
5198:  MOVFF  FF5,FEE
519C:  DECFSZ 01,F
519E:  BRA    5196
....................          nokia_bitmap(j, (int8)(40 - abs(sin((k++) * PI / 20) * 36)), Temp, 8, 8); 
51A0:  MOVLB  2
51A2:  MOVFF  222,03
51A6:  MOVF   x21,W
51A8:  INCF   x21,F
51AA:  BTFSC  FD8.2
51AC:  INCF   x22,F
51AE:  MOVLB  5
51B0:  MOVWF  x0E
51B2:  MOVFF  03,50F
51B6:  MOVFF  03,549
51BA:  MOVWF  x48
51BC:  MOVLB  0
51BE:  CALL   33DC
51C2:  MOVFF  03,54B
51C6:  MOVFF  02,54A
51CA:  MOVFF  01,549
51CE:  MOVFF  00,548
51D2:  MOVLW  DB
51D4:  MOVLB  5
51D6:  MOVWF  x4F
51D8:  MOVLW  0F
51DA:  MOVWF  x4E
51DC:  MOVLW  49
51DE:  MOVWF  x4D
51E0:  MOVLW  80
51E2:  MOVWF  x4C
51E4:  MOVLB  0
51E6:  CALL   2E5A
51EA:  MOVFF  00,50E
51EE:  MOVFF  01,50F
51F2:  MOVFF  02,510
51F6:  MOVFF  03,511
51FA:  MOVFF  03,53E
51FE:  MOVFF  02,53D
5202:  MOVFF  01,53C
5206:  MOVFF  00,53B
520A:  MOVLB  5
520C:  CLRF   x42
520E:  CLRF   x41
5210:  MOVLW  20
5212:  MOVWF  x40
5214:  MOVLW  83
5216:  MOVWF  x3F
5218:  MOVLB  0
521A:  CALL   2F50
521E:  MOVFF  00,50E
5222:  MOVFF  01,50F
5226:  MOVFF  02,510
522A:  MOVFF  03,511
522E:  MOVFF  03,515
5232:  MOVFF  02,514
5236:  MOVFF  01,513
523A:  MOVFF  00,512
523E:  CALL   379A
5242:  MOVFF  00,50E
5246:  MOVFF  01,50F
524A:  MOVFF  02,510
524E:  MOVFF  03,511
5252:  MOVFF  03,54B
5256:  MOVFF  02,54A
525A:  MOVFF  01,549
525E:  MOVFF  00,548
5262:  MOVLB  5
5264:  CLRF   x4F
5266:  CLRF   x4E
5268:  MOVLW  10
526A:  MOVWF  x4D
526C:  MOVLW  84
526E:  MOVWF  x4C
5270:  MOVLB  0
5272:  CALL   2E5A
5276:  MOVFF  00,50E
527A:  MOVFF  01,50F
527E:  MOVFF  02,510
5282:  MOVFF  03,511
5286:  MOVFF  00,00
528A:  MOVFF  01,01
528E:  MOVFF  02,02
5292:  MOVFF  03,03
5296:  BCF    01.7
5298:  MOVFF  FEA,50F
529C:  MOVFF  FE9,50E
52A0:  BSF    FD8.1
52A2:  MOVLB  5
52A4:  CLRF   x4B
52A6:  CLRF   x4A
52A8:  MOVLW  20
52AA:  MOVWF  x49
52AC:  MOVLW  84
52AE:  MOVWF  x48
52B0:  MOVFF  03,54F
52B4:  MOVFF  02,54E
52B8:  MOVFF  01,54D
52BC:  MOVFF  00,54C
52C0:  MOVLB  0
52C2:  CALL   30AE
52C6:  MOVFF  50F,FEA
52CA:  MOVFF  50E,FE9
52CE:  MOVFF  03,547
52D2:  MOVFF  02,546
52D6:  MOVFF  01,545
52DA:  MOVFF  00,544
52DE:  CALL   33A0
52E2:  MOVFF  01,510
52E6:  MOVFF  21F,511
52EA:  MOVFF  01,512
52EE:  MOVLW  03
52F0:  MOVLB  5
52F2:  MOVWF  x14
52F4:  MOVLW  16
52F6:  MOVWF  x13
52F8:  MOVLW  08
52FA:  MOVWF  x15
52FC:  MOVWF  x16
52FE:  MOVLB  0
5300:  CALL   4084
....................           
....................          j = j + offset; 
5304:  MOVLB  2
5306:  MOVF   x23,W
5308:  ADDWF  x1F,F
530A:  MOVF   x24,W
530C:  ADDWFC x20,F
....................           
....................          if (j > 76) 
530E:  MOVF   x20,F
5310:  BNZ   5318
5312:  MOVF   x1F,W
5314:  SUBLW  4C
5316:  BC    531C
....................          { 
....................             offset =- 1; 
5318:  SETF   x24
531A:  SETF   x23
....................          } 
....................           
....................          if (j == 0) 
531C:  MOVF   x1F,F
531E:  BNZ   532A
5320:  MOVF   x20,F
5322:  BNZ   532A
....................          { 
....................             offset = 1; 
5324:  CLRF   x24
5326:  MOVLW  01
5328:  MOVWF  x23
....................          } 
....................  
....................          nokia_imprime_memoria(); 
532A:  MOVLB  0
532C:  CALL   2D96
....................          nokia_borra_memoria(); 
5330:  CALL   2DDA
....................           
....................          delay_ms(30); 
5334:  MOVLW  1E
5336:  MOVLB  5
5338:  MOVWF  x0F
533A:  MOVLB  0
533C:  CALL   2948
....................       } 
5340:  MOVLB  2
5342:  MOVF   x27,W
5344:  BTFSC  FD8.2
5346:  DECF   x28,F
5348:  DECF   x27,F
534A:  BRA    50F0
....................        
....................       for (i = -63; i < 20; i++) 
534C:  SETF   x28
534E:  MOVLW  C1
5350:  MOVWF  x27
5352:  BTFSC  x28.7
5354:  BRA    5364
5356:  MOVF   x28,F
5358:  BTFSS  FD8.2
535A:  BRA    55EC
535C:  MOVF   x27,W
535E:  SUBLW  13
5360:  BTFSS  FD8.0
5362:  BRA    55EC
....................       { 
....................          memcpy(Temp, logodspic, sizeof(logodspic)); 
5364:  MOVLW  03
5366:  MOVWF  FEA
5368:  MOVLW  16
536A:  MOVWF  FE9
536C:  MOVLW  D5
536E:  MOVWF  01
5370:  CLRF   FF7
5372:  MOVLW  00
5374:  MOVLB  0
5376:  CALL   27D8
537A:  TBLRD*-
537C:  TBLRD*+
537E:  MOVFF  FF5,FEE
5382:  DECFSZ 01,F
5384:  BRA    537C
....................          nokia_bitmap(7, 29, Temp, 71, 19); 
5386:  MOVLW  07
5388:  MOVLB  5
538A:  MOVWF  x11
538C:  MOVLW  1D
538E:  MOVWF  x12
5390:  MOVLW  03
5392:  MOVWF  x14
5394:  MOVLW  16
5396:  MOVWF  x13
5398:  MOVLW  47
539A:  MOVWF  x15
539C:  MOVLW  13
539E:  MOVWF  x16
53A0:  MOVLB  0
53A2:  CALL   4084
....................           
....................          memcpy(Temp, logonokia, sizeof(logonokia)); 
53A6:  MOVLW  03
53A8:  MOVWF  FEA
53AA:  MOVLW  16
53AC:  MOVWF  FE9
53AE:  MOVLW  A8
53B0:  MOVWF  01
53B2:  CLRF   FF7
53B4:  MOVLW  00
53B6:  CALL   2720
53BA:  TBLRD*-
53BC:  TBLRD*+
53BE:  MOVFF  FF5,FEE
53C2:  DECFSZ 01,F
53C4:  BRA    53BC
....................          nokia_bitmap(0, 0, Temp, 83, 15); 
53C6:  MOVLB  5
53C8:  CLRF   x11
53CA:  CLRF   x12
53CC:  MOVLW  03
53CE:  MOVWF  x14
53D0:  MOVLW  16
53D2:  MOVWF  x13
53D4:  MOVLW  53
53D6:  MOVWF  x15
53D8:  MOVLW  0F
53DA:  MOVWF  x16
53DC:  MOVLB  0
53DE:  CALL   4084
....................           
....................          memcpy(Temp, nocturno, sizeof(nocturno)); 
53E2:  MOVLW  03
53E4:  MOVWF  FEA
53E6:  MOVLW  16
53E8:  MOVWF  FE9
53EA:  MOVLW  3F
53EC:  MOVWF  01
53EE:  CLRF   FF7
53F0:  MOVLW  00
53F2:  CALL   28BE
53F6:  TBLRD*-
53F8:  TBLRD*+
53FA:  MOVFF  FF5,FEE
53FE:  DECFSZ 01,F
5400:  BRA    53F8
....................          nokia_bitmap(i, 18, Temp, 63, 7); 
5402:  MOVFF  227,511
5406:  MOVLW  12
5408:  MOVLB  5
540A:  MOVWF  x12
540C:  MOVLW  03
540E:  MOVWF  x14
5410:  MOVLW  16
5412:  MOVWF  x13
5414:  MOVLW  3F
5416:  MOVWF  x15
5418:  MOVLW  07
541A:  MOVWF  x16
541C:  MOVLB  0
541E:  CALL   4084
....................  
....................          memcpy(Temp, bola, sizeof(bola)); 
5422:  MOVLW  03
5424:  MOVWF  FEA
5426:  MOVLW  16
5428:  MOVWF  FE9
542A:  MOVLW  08
542C:  MOVWF  01
542E:  CLRF   FF7
5430:  MOVLW  00
5432:  CALL   290E
5436:  TBLRD*-
5438:  TBLRD*+
543A:  MOVFF  FF5,FEE
543E:  DECFSZ 01,F
5440:  BRA    5438
....................          nokia_bitmap(j, (int8)(40 - abs(sin((k++) * PI / 20) * 36)), Temp, 8, 8); 
5442:  MOVLB  2
5444:  MOVFF  222,03
5448:  MOVF   x21,W
544A:  INCF   x21,F
544C:  BTFSC  FD8.2
544E:  INCF   x22,F
5450:  MOVLB  5
5452:  MOVWF  x0E
5454:  MOVFF  03,50F
5458:  MOVFF  03,549
545C:  MOVWF  x48
545E:  MOVLB  0
5460:  CALL   33DC
5464:  MOVFF  03,54B
5468:  MOVFF  02,54A
546C:  MOVFF  01,549
5470:  MOVFF  00,548
5474:  MOVLW  DB
5476:  MOVLB  5
5478:  MOVWF  x4F
547A:  MOVLW  0F
547C:  MOVWF  x4E
547E:  MOVLW  49
5480:  MOVWF  x4D
5482:  MOVLW  80
5484:  MOVWF  x4C
5486:  MOVLB  0
5488:  CALL   2E5A
548C:  MOVFF  00,50E
5490:  MOVFF  01,50F
5494:  MOVFF  02,510
5498:  MOVFF  03,511
549C:  MOVFF  03,53E
54A0:  MOVFF  02,53D
54A4:  MOVFF  01,53C
54A8:  MOVFF  00,53B
54AC:  MOVLB  5
54AE:  CLRF   x42
54B0:  CLRF   x41
54B2:  MOVLW  20
54B4:  MOVWF  x40
54B6:  MOVLW  83
54B8:  MOVWF  x3F
54BA:  MOVLB  0
54BC:  CALL   2F50
54C0:  MOVFF  00,50E
54C4:  MOVFF  01,50F
54C8:  MOVFF  02,510
54CC:  MOVFF  03,511
54D0:  MOVFF  03,515
54D4:  MOVFF  02,514
54D8:  MOVFF  01,513
54DC:  MOVFF  00,512
54E0:  CALL   379A
54E4:  MOVFF  00,50E
54E8:  MOVFF  01,50F
54EC:  MOVFF  02,510
54F0:  MOVFF  03,511
54F4:  MOVFF  03,54B
54F8:  MOVFF  02,54A
54FC:  MOVFF  01,549
5500:  MOVFF  00,548
5504:  MOVLB  5
5506:  CLRF   x4F
5508:  CLRF   x4E
550A:  MOVLW  10
550C:  MOVWF  x4D
550E:  MOVLW  84
5510:  MOVWF  x4C
5512:  MOVLB  0
5514:  CALL   2E5A
5518:  MOVFF  00,50E
551C:  MOVFF  01,50F
5520:  MOVFF  02,510
5524:  MOVFF  03,511
5528:  MOVFF  00,00
552C:  MOVFF  01,01
5530:  MOVFF  02,02
5534:  MOVFF  03,03
5538:  BCF    01.7
553A:  MOVFF  FEA,50F
553E:  MOVFF  FE9,50E
5542:  BSF    FD8.1
5544:  MOVLB  5
5546:  CLRF   x4B
5548:  CLRF   x4A
554A:  MOVLW  20
554C:  MOVWF  x49
554E:  MOVLW  84
5550:  MOVWF  x48
5552:  MOVFF  03,54F
5556:  MOVFF  02,54E
555A:  MOVFF  01,54D
555E:  MOVFF  00,54C
5562:  MOVLB  0
5564:  CALL   30AE
5568:  MOVFF  50F,FEA
556C:  MOVFF  50E,FE9
5570:  MOVFF  03,547
5574:  MOVFF  02,546
5578:  MOVFF  01,545
557C:  MOVFF  00,544
5580:  CALL   33A0
5584:  MOVFF  01,510
5588:  MOVFF  21F,511
558C:  MOVFF  01,512
5590:  MOVLW  03
5592:  MOVLB  5
5594:  MOVWF  x14
5596:  MOVLW  16
5598:  MOVWF  x13
559A:  MOVLW  08
559C:  MOVWF  x15
559E:  MOVWF  x16
55A0:  MOVLB  0
55A2:  CALL   4084
....................           
....................          j = j + offset; 
55A6:  MOVLB  2
55A8:  MOVF   x23,W
55AA:  ADDWF  x1F,F
55AC:  MOVF   x24,W
55AE:  ADDWFC x20,F
....................           
....................          if (j > 76) 
55B0:  MOVF   x20,F
55B2:  BNZ   55BA
55B4:  MOVF   x1F,W
55B6:  SUBLW  4C
55B8:  BC    55BE
....................          { 
....................             offset =- 1; 
55BA:  SETF   x24
55BC:  SETF   x23
....................          } 
....................          if (j == 0) 
55BE:  MOVF   x1F,F
55C0:  BNZ   55CC
55C2:  MOVF   x20,F
55C4:  BNZ   55CC
....................          { 
....................             offset = 1; 
55C6:  CLRF   x24
55C8:  MOVLW  01
55CA:  MOVWF  x23
....................          } 
....................  
....................          nokia_imprime_memoria(); 
55CC:  MOVLB  0
55CE:  CALL   2D96
....................          nokia_borra_memoria(); 
55D2:  CALL   2DDA
....................           
....................          delay_ms(25); 
55D6:  MOVLW  19
55D8:  MOVLB  5
55DA:  MOVWF  x0F
55DC:  MOVLB  0
55DE:  CALL   2948
....................       } 
55E2:  MOVLB  2
55E4:  INCF   x27,F
55E6:  BTFSC  FD8.2
55E8:  INCF   x28,F
55EA:  BRA    5352
....................  
....................  
....................       for (i = 0; i < 50; i++) 
55EC:  CLRF   x28
55EE:  CLRF   x27
55F0:  BTFSC  x28.7
55F2:  BRA    5602
55F4:  MOVF   x28,F
55F6:  BTFSS  FD8.2
55F8:  BRA    588A
55FA:  MOVF   x27,W
55FC:  SUBLW  31
55FE:  BTFSS  FD8.0
5600:  BRA    588A
....................       { 
....................          memcpy(Temp, logodspic, sizeof(logodspic)); 
5602:  MOVLW  03
5604:  MOVWF  FEA
5606:  MOVLW  16
5608:  MOVWF  FE9
560A:  MOVLW  D5
560C:  MOVWF  01
560E:  CLRF   FF7
5610:  MOVLW  00
5612:  MOVLB  0
5614:  CALL   27D8
5618:  TBLRD*-
561A:  TBLRD*+
561C:  MOVFF  FF5,FEE
5620:  DECFSZ 01,F
5622:  BRA    561A
....................          nokia_bitmap(7, 29, Temp, 71, 19); 
5624:  MOVLW  07
5626:  MOVLB  5
5628:  MOVWF  x11
562A:  MOVLW  1D
562C:  MOVWF  x12
562E:  MOVLW  03
5630:  MOVWF  x14
5632:  MOVLW  16
5634:  MOVWF  x13
5636:  MOVLW  47
5638:  MOVWF  x15
563A:  MOVLW  13
563C:  MOVWF  x16
563E:  MOVLB  0
5640:  CALL   4084
....................           
....................          memcpy(Temp, logonokia, sizeof(logonokia)); 
5644:  MOVLW  03
5646:  MOVWF  FEA
5648:  MOVLW  16
564A:  MOVWF  FE9
564C:  MOVLW  A8
564E:  MOVWF  01
5650:  CLRF   FF7
5652:  MOVLW  00
5654:  CALL   2720
5658:  TBLRD*-
565A:  TBLRD*+
565C:  MOVFF  FF5,FEE
5660:  DECFSZ 01,F
5662:  BRA    565A
....................          nokia_bitmap(0, 0, Temp, 83, 15); 
5664:  MOVLB  5
5666:  CLRF   x11
5668:  CLRF   x12
566A:  MOVLW  03
566C:  MOVWF  x14
566E:  MOVLW  16
5670:  MOVWF  x13
5672:  MOVLW  53
5674:  MOVWF  x15
5676:  MOVLW  0F
5678:  MOVWF  x16
567A:  MOVLB  0
567C:  CALL   4084
....................           
....................          memcpy(Temp, nocturno, sizeof(nocturno)); 
5680:  MOVLW  03
5682:  MOVWF  FEA
5684:  MOVLW  16
5686:  MOVWF  FE9
5688:  MOVLW  3F
568A:  MOVWF  01
568C:  CLRF   FF7
568E:  MOVLW  00
5690:  CALL   28BE
5694:  TBLRD*-
5696:  TBLRD*+
5698:  MOVFF  FF5,FEE
569C:  DECFSZ 01,F
569E:  BRA    5696
....................          nokia_bitmap(20, 18, Temp, 63, 7); 
56A0:  MOVLW  14
56A2:  MOVLB  5
56A4:  MOVWF  x11
56A6:  MOVLW  12
56A8:  MOVWF  x12
56AA:  MOVLW  03
56AC:  MOVWF  x14
56AE:  MOVLW  16
56B0:  MOVWF  x13
56B2:  MOVLW  3F
56B4:  MOVWF  x15
56B6:  MOVLW  07
56B8:  MOVWF  x16
56BA:  MOVLB  0
56BC:  CALL   4084
....................  
....................          memcpy(Temp, bola, sizeof(bola)); 
56C0:  MOVLW  03
56C2:  MOVWF  FEA
56C4:  MOVLW  16
56C6:  MOVWF  FE9
56C8:  MOVLW  08
56CA:  MOVWF  01
56CC:  CLRF   FF7
56CE:  MOVLW  00
56D0:  CALL   290E
56D4:  TBLRD*-
56D6:  TBLRD*+
56D8:  MOVFF  FF5,FEE
56DC:  DECFSZ 01,F
56DE:  BRA    56D6
....................          nokia_bitmap(j, (int8)(40 - abs(sin((k++) * PI / 20) * 36)), Temp, 8, 8); 
56E0:  MOVLB  2
56E2:  MOVFF  222,03
56E6:  MOVF   x21,W
56E8:  INCF   x21,F
56EA:  BTFSC  FD8.2
56EC:  INCF   x22,F
56EE:  MOVLB  5
56F0:  MOVWF  x0E
56F2:  MOVFF  03,50F
56F6:  MOVFF  03,549
56FA:  MOVWF  x48
56FC:  MOVLB  0
56FE:  CALL   33DC
5702:  MOVFF  03,54B
5706:  MOVFF  02,54A
570A:  MOVFF  01,549
570E:  MOVFF  00,548
5712:  MOVLW  DB
5714:  MOVLB  5
5716:  MOVWF  x4F
5718:  MOVLW  0F
571A:  MOVWF  x4E
571C:  MOVLW  49
571E:  MOVWF  x4D
5720:  MOVLW  80
5722:  MOVWF  x4C
5724:  MOVLB  0
5726:  CALL   2E5A
572A:  MOVFF  00,50E
572E:  MOVFF  01,50F
5732:  MOVFF  02,510
5736:  MOVFF  03,511
573A:  MOVFF  03,53E
573E:  MOVFF  02,53D
5742:  MOVFF  01,53C
5746:  MOVFF  00,53B
574A:  MOVLB  5
574C:  CLRF   x42
574E:  CLRF   x41
5750:  MOVLW  20
5752:  MOVWF  x40
5754:  MOVLW  83
5756:  MOVWF  x3F
5758:  MOVLB  0
575A:  CALL   2F50
575E:  MOVFF  00,50E
5762:  MOVFF  01,50F
5766:  MOVFF  02,510
576A:  MOVFF  03,511
576E:  MOVFF  03,515
5772:  MOVFF  02,514
5776:  MOVFF  01,513
577A:  MOVFF  00,512
577E:  CALL   379A
5782:  MOVFF  00,50E
5786:  MOVFF  01,50F
578A:  MOVFF  02,510
578E:  MOVFF  03,511
5792:  MOVFF  03,54B
5796:  MOVFF  02,54A
579A:  MOVFF  01,549
579E:  MOVFF  00,548
57A2:  MOVLB  5
57A4:  CLRF   x4F
57A6:  CLRF   x4E
57A8:  MOVLW  10
57AA:  MOVWF  x4D
57AC:  MOVLW  84
57AE:  MOVWF  x4C
57B0:  MOVLB  0
57B2:  CALL   2E5A
57B6:  MOVFF  00,50E
57BA:  MOVFF  01,50F
57BE:  MOVFF  02,510
57C2:  MOVFF  03,511
57C6:  MOVFF  00,00
57CA:  MOVFF  01,01
57CE:  MOVFF  02,02
57D2:  MOVFF  03,03
57D6:  BCF    01.7
57D8:  MOVFF  FEA,50F
57DC:  MOVFF  FE9,50E
57E0:  BSF    FD8.1
57E2:  MOVLB  5
57E4:  CLRF   x4B
57E6:  CLRF   x4A
57E8:  MOVLW  20
57EA:  MOVWF  x49
57EC:  MOVLW  84
57EE:  MOVWF  x48
57F0:  MOVFF  03,54F
57F4:  MOVFF  02,54E
57F8:  MOVFF  01,54D
57FC:  MOVFF  00,54C
5800:  MOVLB  0
5802:  CALL   30AE
5806:  MOVFF  50F,FEA
580A:  MOVFF  50E,FE9
580E:  MOVFF  03,547
5812:  MOVFF  02,546
5816:  MOVFF  01,545
581A:  MOVFF  00,544
581E:  CALL   33A0
5822:  MOVFF  01,510
5826:  MOVFF  21F,511
582A:  MOVFF  01,512
582E:  MOVLW  03
5830:  MOVLB  5
5832:  MOVWF  x14
5834:  MOVLW  16
5836:  MOVWF  x13
5838:  MOVLW  08
583A:  MOVWF  x15
583C:  MOVWF  x16
583E:  MOVLB  0
5840:  CALL   4084
....................           
....................          j = j + offset; 
5844:  MOVLB  2
5846:  MOVF   x23,W
5848:  ADDWF  x1F,F
584A:  MOVF   x24,W
584C:  ADDWFC x20,F
....................           
....................          if (j > 76) 
584E:  MOVF   x20,F
5850:  BNZ   5858
5852:  MOVF   x1F,W
5854:  SUBLW  4C
5856:  BC    585C
....................          { 
....................             offset =- 1; 
5858:  SETF   x24
585A:  SETF   x23
....................          } 
....................          if (j == 0) 
585C:  MOVF   x1F,F
585E:  BNZ   586A
5860:  MOVF   x20,F
5862:  BNZ   586A
....................          {     
....................             offset = 1; 
5864:  CLRF   x24
5866:  MOVLW  01
5868:  MOVWF  x23
....................          } 
....................           
....................          nokia_imprime_memoria(); 
586A:  MOVLB  0
586C:  CALL   2D96
....................          nokia_borra_memoria(); 
5870:  CALL   2DDA
....................           
....................          delay_ms(30); 
5874:  MOVLW  1E
5876:  MOVLB  5
5878:  MOVWF  x0F
587A:  MOVLB  0
587C:  CALL   2948
....................       } 
5880:  MOVLB  2
5882:  INCF   x27,F
5884:  BTFSC  FD8.2
5886:  INCF   x28,F
5888:  BRA    55F0
....................        
....................       memcpy(Temp, logodspic, sizeof(logodspic)); 
588A:  MOVLW  03
588C:  MOVWF  FEA
588E:  MOVLW  16
5890:  MOVWF  FE9
5892:  MOVLW  D5
5894:  MOVWF  01
5896:  CLRF   FF7
5898:  MOVLW  00
589A:  MOVLB  0
589C:  CALL   27D8
58A0:  TBLRD*-
58A2:  TBLRD*+
58A4:  MOVFF  FF5,FEE
58A8:  DECFSZ 01,F
58AA:  BRA    58A2
....................       nokia_bitmap(7, 29, Temp, 71, 19); 
58AC:  MOVLW  07
58AE:  MOVLB  5
58B0:  MOVWF  x11
58B2:  MOVLW  1D
58B4:  MOVWF  x12
58B6:  MOVLW  03
58B8:  MOVWF  x14
58BA:  MOVLW  16
58BC:  MOVWF  x13
58BE:  MOVLW  47
58C0:  MOVWF  x15
58C2:  MOVLW  13
58C4:  MOVWF  x16
58C6:  MOVLB  0
58C8:  CALL   4084
....................     
....................       memcpy(Temp, logonokia, sizeof(logonokia)); 
58CC:  MOVLW  03
58CE:  MOVWF  FEA
58D0:  MOVLW  16
58D2:  MOVWF  FE9
58D4:  MOVLW  A8
58D6:  MOVWF  01
58D8:  CLRF   FF7
58DA:  MOVLW  00
58DC:  CALL   2720
58E0:  TBLRD*-
58E2:  TBLRD*+
58E4:  MOVFF  FF5,FEE
58E8:  DECFSZ 01,F
58EA:  BRA    58E2
....................       nokia_bitmap(0, 0, Temp, 83, 15); 
58EC:  MOVLB  5
58EE:  CLRF   x11
58F0:  CLRF   x12
58F2:  MOVLW  03
58F4:  MOVWF  x14
58F6:  MOVLW  16
58F8:  MOVWF  x13
58FA:  MOVLW  53
58FC:  MOVWF  x15
58FE:  MOVLW  0F
5900:  MOVWF  x16
5902:  MOVLB  0
5904:  CALL   4084
....................     
....................       memcpy(Temp, nocturno, sizeof(nocturno)); 
5908:  MOVLW  03
590A:  MOVWF  FEA
590C:  MOVLW  16
590E:  MOVWF  FE9
5910:  MOVLW  3F
5912:  MOVWF  01
5914:  CLRF   FF7
5916:  MOVLW  00
5918:  CALL   28BE
591C:  TBLRD*-
591E:  TBLRD*+
5920:  MOVFF  FF5,FEE
5924:  DECFSZ 01,F
5926:  BRA    591E
....................       nokia_bitmap(20, 18, Temp, 63, 7); 
5928:  MOVLW  14
592A:  MOVLB  5
592C:  MOVWF  x11
592E:  MOVLW  12
5930:  MOVWF  x12
5932:  MOVLW  03
5934:  MOVWF  x14
5936:  MOVLW  16
5938:  MOVWF  x13
593A:  MOVLW  3F
593C:  MOVWF  x15
593E:  MOVLW  07
5940:  MOVWF  x16
5942:  MOVLB  0
5944:  CALL   4084
....................     
....................       nokia_imprime_memoria(); 
5948:  CALL   2D96
....................     
....................       a = 0x0C; 
594C:  MOVLW  0C
594E:  MOVLB  2
5950:  MOVWF  x1E
....................     
....................       for (i = 0; i < 10; i++)  
5952:  CLRF   x28
5954:  CLRF   x27
5956:  BTFSC  x28.7
5958:  BRA    5964
595A:  MOVF   x28,F
595C:  BNZ   59BC
595E:  MOVF   x27,W
5960:  SUBLW  09
5962:  BNC   59BC
....................       { 
....................          switch (a)  
....................          { 
5964:  MOVF   x1E,W
5966:  XORLW  0C
5968:  MOVLB  0
596A:  BZ    5972
596C:  XORLW  01
596E:  BZ    5992
5970:  BRA    59B2
....................             case 0x0c: 
....................                nokia_write_command(0x0D);   // Modo normal 
5972:  MOVLW  0D
5974:  MOVLB  5
5976:  MOVWF  x13
5978:  MOVLB  0
597A:  CALL   29A6
....................                a = 0x0D; 
597E:  MOVLW  0D
5980:  MOVLB  2
5982:  MOVWF  x1E
....................              
....................                delay_ms(200); 
5984:  MOVLW  C8
5986:  MOVLB  5
5988:  MOVWF  x0F
598A:  MOVLB  0
598C:  CALL   2948
....................              
....................                break; 
5990:  BRA    59B2
....................           
....................             case 0x0D: 
....................                nokia_write_command(0x0C);   // Modo inverso 
5992:  MOVLW  0C
5994:  MOVLB  5
5996:  MOVWF  x13
5998:  MOVLB  0
599A:  CALL   29A6
....................                a = 0x0C; 
599E:  MOVLW  0C
59A0:  MOVLB  2
59A2:  MOVWF  x1E
....................              
....................                delay_ms(200); 
59A4:  MOVLW  C8
59A6:  MOVLB  5
59A8:  MOVWF  x0F
59AA:  MOVLB  0
59AC:  CALL   2948
....................              
....................                break; 
59B0:  BRA    59B2
....................          } 
....................       } 
59B2:  MOVLB  2
59B4:  INCF   x27,F
59B6:  BTFSC  FD8.2
59B8:  INCF   x28,F
59BA:  BRA    5956
....................  
....................       nokia_borra_memoria(); 
59BC:  MOVLB  0
59BE:  CALL   2DDA
....................     
....................       for (l = 40; l > -64; l--) 
59C2:  MOVLB  2
59C4:  CLRF   x26
59C6:  MOVLW  28
59C8:  MOVWF  x25
59CA:  BTFSS  x26.7
59CC:  BRA    59E2
59CE:  MOVF   x26,W
59D0:  SUBLW  FE
59D2:  BTFSC  FD8.0
59D4:  BRA    5B78
59D6:  XORLW  FF
59D8:  BNZ   59E2
59DA:  MOVF   x25,W
59DC:  SUBLW  C0
59DE:  BTFSC  FD8.0
59E0:  BRA    5B78
....................       { 
....................          nokia_texto(0, l, NORMAL, str14); 
59E2:  MOVLB  5
59E4:  CLRF   x10
59E6:  MOVFF  225,511
59EA:  MOVLW  02
59EC:  MOVWF  x12
59EE:  MOVWF  x14
59F0:  MOVLW  B2
59F2:  MOVWF  x13
59F4:  MOVLB  0
59F6:  CALL   2B14
....................          nokia_texto(0, l + 8, NORMAL, str15); 
59FA:  MOVLW  08
59FC:  MOVLB  2
59FE:  ADDWF  x25,W
5A00:  MOVLB  5
5A02:  MOVWF  x0E
5A04:  MOVLW  00
5A06:  MOVLB  2
5A08:  ADDWFC x26,W
5A0A:  MOVLB  5
5A0C:  MOVWF  x0F
5A0E:  CLRF   x10
5A10:  MOVFF  50E,511
5A14:  MOVLW  02
5A16:  MOVWF  x12
5A18:  MOVWF  x14
5A1A:  MOVLW  BF
5A1C:  MOVWF  x13
5A1E:  MOVLB  0
5A20:  CALL   2B14
....................          nokia_texto(0, l + 16, NORMAL, str16); 
5A24:  MOVLW  10
5A26:  MOVLB  2
5A28:  ADDWF  x25,W
5A2A:  MOVLB  5
5A2C:  MOVWF  x0E
5A2E:  MOVLW  00
5A30:  MOVLB  2
5A32:  ADDWFC x26,W
5A34:  MOVLB  5
5A36:  MOVWF  x0F
5A38:  CLRF   x10
5A3A:  MOVFF  50E,511
5A3E:  MOVLW  02
5A40:  MOVWF  x12
5A42:  MOVWF  x14
5A44:  MOVLW  CE
5A46:  MOVWF  x13
5A48:  MOVLB  0
5A4A:  CALL   2B14
....................          nokia_texto(0, l + 24, NORMAL, str17); 
5A4E:  MOVLW  18
5A50:  MOVLB  2
5A52:  ADDWF  x25,W
5A54:  MOVLB  5
5A56:  MOVWF  x0E
5A58:  MOVLW  00
5A5A:  MOVLB  2
5A5C:  ADDWFC x26,W
5A5E:  MOVLB  5
5A60:  MOVWF  x0F
5A62:  CLRF   x10
5A64:  MOVFF  50E,511
5A68:  MOVLW  02
5A6A:  MOVWF  x12
5A6C:  MOVWF  x14
5A6E:  MOVLW  DC
5A70:  MOVWF  x13
5A72:  MOVLB  0
5A74:  CALL   2B14
....................          nokia_texto(0, l + 32, NORMAL, str18); 
5A78:  MOVLW  20
5A7A:  MOVLB  2
5A7C:  ADDWF  x25,W
5A7E:  MOVLB  5
5A80:  MOVWF  x0E
5A82:  MOVLW  00
5A84:  MOVLB  2
5A86:  ADDWFC x26,W
5A88:  MOVLB  5
5A8A:  MOVWF  x0F
5A8C:  CLRF   x10
5A8E:  MOVFF  50E,511
5A92:  MOVLW  02
5A94:  MOVWF  x12
5A96:  MOVWF  x14
5A98:  MOVLW  E8
5A9A:  MOVWF  x13
5A9C:  MOVLB  0
5A9E:  CALL   2B14
....................          nokia_texto(0, l + 40, NORMAL, str19); 
5AA2:  MOVLW  28
5AA4:  MOVLB  2
5AA6:  ADDWF  x25,W
5AA8:  MOVLB  5
5AAA:  MOVWF  x0E
5AAC:  MOVLW  00
5AAE:  MOVLB  2
5AB0:  ADDWFC x26,W
5AB2:  MOVLB  5
5AB4:  MOVWF  x0F
5AB6:  CLRF   x10
5AB8:  MOVFF  50E,511
5ABC:  MOVLW  02
5ABE:  MOVWF  x12
5AC0:  MOVWF  x14
5AC2:  MOVLW  F1
5AC4:  MOVWF  x13
5AC6:  MOVLB  0
5AC8:  CALL   2B14
....................          nokia_texto(0, l + 48, NORMAL, str20); 
5ACC:  MOVLW  30
5ACE:  MOVLB  2
5AD0:  ADDWF  x25,W
5AD2:  MOVLB  5
5AD4:  MOVWF  x0E
5AD6:  MOVLW  00
5AD8:  MOVLB  2
5ADA:  ADDWFC x26,W
5ADC:  MOVLB  5
5ADE:  MOVWF  x0F
5AE0:  CLRF   x10
5AE2:  MOVFF  50E,511
5AE6:  MOVLW  02
5AE8:  MOVWF  x12
5AEA:  MOVWF  x14
5AEC:  SETF   x13
5AEE:  MOVLB  0
5AF0:  CALL   2B14
....................          nokia_texto(20, l + 56, NORMAL, str21); 
5AF4:  MOVLW  38
5AF6:  MOVLB  2
5AF8:  ADDWF  x25,W
5AFA:  MOVLB  5
5AFC:  MOVWF  x0E
5AFE:  MOVLW  00
5B00:  MOVLB  2
5B02:  ADDWFC x26,W
5B04:  MOVLB  5
5B06:  MOVWF  x0F
5B08:  MOVLW  14
5B0A:  MOVWF  x10
5B0C:  MOVFF  50E,511
5B10:  MOVLW  02
5B12:  MOVWF  x12
5B14:  MOVLW  03
5B16:  MOVWF  x14
5B18:  MOVWF  x13
5B1A:  MOVLB  0
5B1C:  CALL   2B14
....................          nokia_texto(10, l + 64, NEGRITA, str22); 
5B20:  MOVLW  40
5B22:  MOVLB  2
5B24:  ADDWF  x25,W
5B26:  MOVLB  5
5B28:  MOVWF  x0E
5B2A:  MOVLW  00
5B2C:  MOVLB  2
5B2E:  ADDWFC x26,W
5B30:  MOVLB  5
5B32:  MOVWF  x0F
5B34:  MOVLW  0A
5B36:  MOVWF  x10
5B38:  MOVFF  50E,511
5B3C:  CLRF   x12
5B3E:  MOVLW  03
5B40:  MOVWF  x14
5B42:  MOVLW  07
5B44:  MOVWF  x13
5B46:  MOVLB  0
5B48:  CALL   2B14
....................           
....................          nokia_imprime_memoria(); 
5B4C:  CALL   2D96
....................           delay_ms(1000); 
5B50:  MOVLW  04
5B52:  MOVLB  5
5B54:  MOVWF  x0E
5B56:  MOVLW  FA
5B58:  MOVWF  x0F
5B5A:  MOVLB  0
5B5C:  CALL   2948
5B60:  MOVLB  5
5B62:  DECFSZ x0E,F
5B64:  BRA    5B56
....................          nokia_borra_memoria(); 
5B66:  MOVLB  0
5B68:  CALL   2DDA
....................           
....................          
....................       }    
5B6C:  MOVLB  2
5B6E:  MOVF   x25,W
5B70:  BTFSC  FD8.2
5B72:  DECF   x26,F
5B74:  DECF   x25,F
5B76:  BRA    59CA
....................    } 
5B78:  MOVLB  5
5B7A:  GOTO   46A6
.................... } 
....................  
....................  
....................  
5B7E:  SLEEP 

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV20 VREGEN NOWDT WDT32768
   Word  3: 8500   CCP2C1 NOPBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
