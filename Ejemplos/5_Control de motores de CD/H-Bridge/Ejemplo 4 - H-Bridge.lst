CCS PCH C Compiler, Version 4.120, 5967               27-ene-13 20:55

               Filename: C:\Users\Jannier\Documents\G-PIC\Pinguino JACSS\Ejemplos\Control de motores de CD\a) H-Bridge\Ejemplo 4 - H-Bridge.lst

               ROM used: 1064 bytes (3%)
                         Largest free fragment is 23508
               RAM used: 42 (2%) at main() level
                         46 (2%) worst case
               Stack:    3 worst case (2 in main + 1 for interrupts)

*
2000:  GOTO   23D4
*
2008:  MOVWF  04
200A:  MOVFF  FD8,05
200E:  MOVFF  FE0,06
2012:  MOVLB  0
2014:  MOVFF  FE9,0C
2018:  MOVFF  FEA,07
201C:  MOVFF  FE1,08
2020:  MOVFF  FE2,09
2024:  MOVFF  FD9,0A
2028:  MOVFF  FDA,0B
202C:  MOVFF  FF3,12
2030:  MOVFF  FF4,13
2034:  MOVFF  FFA,14
2038:  MOVFF  FF5,15
203C:  MOVFF  FF6,16
2040:  MOVFF  FF7,17
2044:  MOVFF  00,0E
2048:  MOVFF  01,0F
204C:  MOVFF  02,10
2050:  MOVFF  03,11
2054:  BTFSS  FA0.1
2056:  GOTO   2060
205A:  BTFSC  FA1.1
205C:  GOTO   20AE
2060:  MOVFF  0E,00
2064:  MOVFF  0F,01
2068:  MOVFF  10,02
206C:  MOVFF  11,03
2070:  MOVFF  0C,FE9
2074:  MOVFF  07,FEA
2078:  BSF    07.7
207A:  MOVFF  08,FE1
207E:  MOVFF  09,FE2
2082:  MOVFF  0A,FD9
2086:  MOVFF  0B,FDA
208A:  MOVFF  12,FF3
208E:  MOVFF  13,FF4
2092:  MOVFF  14,FFA
2096:  MOVFF  15,FF5
209A:  MOVFF  16,FF6
209E:  MOVFF  17,FF7
20A2:  MOVF   04,W
20A4:  MOVFF  06,FE0
20A8:  MOVFF  05,FD8
20AC:  RETFIE 0
.................... /* 
....................    H-Bridge 
....................    Muestra una forma básica de utilizar el Puente H para encender y apagar un  
....................    motor de CD. El motor enciende 3 segundos y se apaga 3 segundos 
....................     
....................    Hardware 
....................    Pinguino JACSS       L293D o SN754410  
....................    Pin_C1            Pin 1 
....................    Pin_B0            Pin 2 
....................    Pin_B1            Pin 7 
....................                      Pin 8 - Conectado a 5V de la G-PiC Lite! 
....................                      Pin 16 - Conectado a fuente de voltaje externa @ 5V 
....................     
....................    Importante: Verificar la hoja de datos del puente H para saber cómo  
....................    conectarlo correctamente 
.................... */ 
.................... #include <Cabecera JACSS.c> 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... //#device ADC = 10 //Define la resolucion del ADC, comentar en caso de usar 8 
.................... #fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL5,CPUDIV1,VREGEN,NOPBADEN 
.................... #use delay(clock=48000000) 
*
23AC:  CLRF   FEA
23AE:  MOVLW  2A
23B0:  MOVWF  FE9
23B2:  MOVF   FEF,W
23B4:  BZ    23D2
23B6:  MOVLW  0F
23B8:  MOVWF  01
23BA:  CLRF   00
23BC:  DECFSZ 00,F
23BE:  BRA    23BC
23C0:  DECFSZ 01,F
23C2:  BRA    23BA
23C4:  MOVLW  8F
23C6:  MOVWF  00
23C8:  DECFSZ 00,F
23CA:  BRA    23C8
23CC:  NOP   
23CE:  DECFSZ FEF,F
23D0:  BRA    23B6
23D2:  RETURN 0
.................... #include <usb_bootloader.h> //Comenta esta línea si no usas Bootloader 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                     USB_BOOTLOADER.H                              //// 
.................... ////                                                                   //// 
.................... ////  This include file must be included by any application loaded     //// 
.................... ////  by the example USB bootloader (ex_usb_bootloader                 //// 
.................... ////                                                                   //// 
.................... ////  The directives in this file relocate the reset and interrupt     //// 
.................... ////  vectors as well as reserving space for the bootloader.           //// 
.................... ////                                                                   //// 
.................... ////  For more documentation see ex_usb_bootloader.c                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// VERSION HISTORY                                                   //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //how big is the bootloader? 
.................... //the bootloader will reside from address 0x0000 to this location.  the 
.................... //application will then sit at this location+1 to the end of program memory. 
.................... //#if defined(__DEBUG) 
.................... #define LOADER_SIZE        (0x1FFF) 
.................... //#else 
.................... //#define LOADER_SIZE        (0x17FF) 
.................... //#endif 
....................  
.................... //the loader and application need a common flag that determines if we are in 
.................... //the bootloader or application, that way the ISR knows where to go.  this 
.................... //is the location in ram that is reserved for this flag. 
.................... #define LOC_IN_LOADER_FLAG  0x25 
....................  
.................... //// --- end configuration --- //////////////////////////////////////////// 
....................  
.................... #reserve LOC_IN_LOADER_FLAG 
....................  
.................... int8 g_InBootloader; 
.................... #locate g_InBootloader=LOC_IN_LOADER_FLAG 
....................  
.................... #define LOADER_START       (0) 
.................... #define LOADER_END         (LOADER_SIZE) 
.................... #define APPLICATION_START  (LOADER_SIZE+1) 
.................... #if defined(__USB_87J50__) 
....................  #define APPLICATION_END    (getenv("PROGRAM_MEMORY")-9) //configuration bits 
.................... #else 
....................  #define APPLICATION_END    (getenv("PROGRAM_MEMORY")-1) 
.................... #endif  
.................... #define APPLICATION_ISR    (APPLICATION_START+8) 
....................  
.................... #ifdef _bootloader 
....................  /* 
....................   Provide an empty application, so if you load this .HEX file into the pic 
....................   without an application this will prevent the pic from executing unknown code. 
....................  */ 
....................  #org APPLICATION_START,APPLICATION_START+0xF 
....................  void BlankApplication(void)  
....................  { 
....................    while(TRUE); 
....................  } 
....................  
....................  //we need to prevent the loader from using application space 
....................  #if (APPLICATION_END > 0x10000) 
....................    #org APPLICATION_START+0x10, 0xFFFF {} 
....................    #if (APPLICATION_END > 0x20000) 
....................       #org 0x10000, 0x1FFFF {} 
....................       #org 0x20000, APPLICATION_END {} 
....................    #else 
....................       #org 0x10000, APPLICATION_END {} 
....................    #endif 
....................  #else 
....................    #org APPLICATION_START+0x10, APPLICATION_END {} 
....................  #endif 
....................  
....................    #define  USB_CONFIG_PID       0x0034 
....................  
....................    #define USB_STRINGS_OVERWRITTEN 
....................    char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
....................    // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored. 
....................    // Strings are saved as unicode. 
....................    // These strings are mostly only displayed during the add hardware wizard. 
....................    // Once the operating system drivers have been installed it will usually display 
....................    // the name from the drivers .INF. 
....................    char const USB_STRING_DESC[]={ 
....................       //string 0 
....................             4, //length of string index 
....................             0x03, //USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................             0x09,0x04,   //Microsoft Defined for US-English 
....................       //string 1  - manufacturer 
....................             8, //length of string index 
....................             0x03, //USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................             'C',0, 
....................             'C',0, 
....................             'S',0, 
....................       //string 2 - product 
....................             30, //length of string index 
....................             0x03, //USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................             'C',0, 
....................             'D',0, 
....................             'C',0, 
....................             ' ',0, 
....................             'B',0, 
....................             'o',0, 
....................             'o',0, 
....................             't',0, 
....................             'l',0, 
....................             'o',0, 
....................             'a',0, 
....................             'd',0, 
....................             'e',0, 
....................             'r',0 
....................    }; 
.................... #endif   //_bootloader 
....................  
.................... #ifndef _bootloader 
....................  //in the application, this moves the reset and isr vector out of the bootload 
....................  //space.  it then reserves the loader space from being used by the application. 
....................  #build(reset=APPLICATION_START, interrupt=APPLICATION_ISR) 
....................  #org 0, LOADER_END {} 
.................... #endif 
....................  
.................... #include <Arduino Functions.c> 
.................... /*  
.................... This library includes the definitions to translate the most common Arduino 
.................... functions to the CCS built-in functions. To see the reference of each 
.................... instruction please refer to the CCS Help File for each CCS functions. 
....................  
.................... Esta librería incluye las definiciones para traducir las funciones de Arduino 
.................... más comunes a las funciones incluidas en CCS. Para obtener la referencia de cada  
.................... función de CCS favor de ver el archivo Help del CCS. 
.................... */ 
....................  
.................... /* Additional libraries */ 
.................... #include <analogWrite.c> 
.................... /*                                     PWM.c 
....................  
.................... Esta libreria contiene funciones diseñadas para la facil y rapida programacion 
.................... de salidas PWM por software a traves del uso del Timer3, al igual que las dos 
.................... salidas de PWM por hardware en Pin_C1 y Pin_C2. 
....................  
.................... La salida de PWM por software tiene una frecuencia aproximada de 250Hz y puede 
.................... configurar el ciclo de trabajo entre 0% y 100%, en intervalos de 10%. 
....................  
.................... La salida de PWM por hardware tiene una frecuencia aproximada de 30kHz y puede 
.................... configurar un ciclo de trabajo entre 0% y 100%, en intervalos de 1%. 
....................  
.................... Los Pins de salida del PWM se seleccionan definiendo PWMx_PIN donde x puede ser 
.................... desde 0 hasta 11. Los pines PWM por default son los siguientes: 
....................  
....................          PWM0_PIN    PIN_B0    
....................          PWM1_PIN    PIN_B1 
....................          PWM2_PIN    PIN_B2 
....................          PWM3_PIN    PIN_B3 
....................          PWM4_PIN    PIN_B4 
....................          PWM5_PIN    PIN_B5 
....................          PWM6_PIN    PIN_B6 
....................          PWM7_PIN    PIN_B7 
....................          PWM8_PIN    PIN_D0 
....................          PWM9_PIN    PIN_D1 
....................          PWM10_PIN   PIN_D2 
....................          PWM11_PIN   PIN_A4 
....................           
....................          PIN_C1 
....................          PIN_C2 
....................              
....................    En caso de seleccionar el Pin_C1 o el Pin_C2 se activará el PWM por hardware 
....................    del pin seleccionado con un ciclo configurable entre 0% y 100% en intervalos 
....................    de 1% 
.................... */ 
.................... #ifndef __Software_PWM__ 
.................... #define __Software_PWM__ 
....................  
.................... int1 _PWM0_Flag,_PWM1_Flag,_PWM2_Flag,_PWM3_Flag,_PWM4_Flag,_PWM5_Flag, 
....................      _PWM6_Flag,_PWM7_Flag,_PWM8_Flag,_PWM9_Flag,_PWM10_Flag,_PWM11_Flag; 
....................  
.................... int8 _PWM0_DutyCycle,_PWM1_DutyCycle,_PWM2_DutyCycle,_PWM3_DutyCycle, 
....................      _PWM4_DutyCycle,_PWM5_DutyCycle,_PWM6_DutyCycle,_PWM7_DutyCycle, 
....................      _PWM8_DutyCycle,_PWM9_DutyCycle,_PWM10_DutyCycle,_PWM11_DutyCycle; 
....................  
.................... #ifndef PWM0_PIN 
....................    #define PWM0_PIN  PIN_B0       //Pin para PWM0 
.................... #endif 
.................... #ifndef PWM1_PIN 
....................    #define PWM1_PIN  PIN_B1       //Pin para PWM1 
.................... #endif 
.................... #ifndef PWM2_PIN 
....................    #define PWM2_PIN  PIN_B2       //Pin para PWM2 
.................... #endif 
.................... #ifndef PWM3_PIN 
....................    #define PWM3_PIN  PIN_B3       //Pin para PWM3 
.................... #endif 
.................... #ifndef PWM4_PIN 
....................    #define PWM4_PIN  PIN_B4       //Pin para PWM4 
.................... #endif 
.................... #ifndef PWM5_PIN 
....................    #define PWM5_PIN  PIN_B5       //Pin para PWM5 
.................... #endif 
.................... #ifndef PWM6_PIN 
....................    #define PWM6_PIN  PIN_B6       //Pin para PWM6 
.................... #endif 
.................... #ifndef PWM7_PIN 
....................    #define PWM7_PIN  PIN_B7       //Pin para PWM7 
.................... #endif 
.................... #ifndef PWM8_PIN 
....................    #define PWM8_PIN  PIN_D0       //Pin para PWM8 
.................... #endif 
.................... #ifndef PWM9_PIN 
....................    #define PWM9_PIN  PIN_D1       //Pin para PWM9 
.................... #endif 
.................... #ifndef PWM10_PIN 
....................    #define PWM10_PIN PIN_D2       //Pin para PWM10 
.................... #endif 
.................... #ifndef PWM11_PIN              
....................    #define PWM11_PIN PIN_A4       //Pin para PWM11 
.................... #endif 
....................  
.................... #define _Set_PWM_Timer3 63135 
.................... #define _totalResolution 10 
....................  
....................  
.................... //****************************************************************************/ 
.................... //                         analogWrite(PWMx,DutyCycle) 
.................... // 
.................... //Funcion que permite la configuracion de PWM por software en cualquier PIN 
.................... //digital disponible. En caso de necesitar mas pines PWM es posible agregarlos  
.................... //añadiendo mas "case" siguiendo la secuencia en las variables. 
.................... // 
.................... // PWMx => Especifica el numero de PWM, cada salida debe tener uno diferente 
.................... // DutyCycle => Porcentaje de ciclo de trabajo del PWM. Es un valor de 0 a 100 
.................... // 
.................... // Ejemplo: 
.................... //          PWM_Output(0,50);   //Salida PWM0 de 50% 
.................... //          PWM_Output(1,0);    //Salida PWM1 de 0% 
.................... //                              //y apaga el PWM para uso como I/O 
.................... //****************************************************************************// 
.................... void analogWrite(int8 _PWMx, int8 _DutyCycle) 
.................... { 
....................    static int1 _T3_Config_Flag = False, _T2_Config_Flag = False; 
....................    //Pregunta si el Timer3 ya ha sido configurado 
....................    //Si el Pin corresponde a un pin de PWM por hardware, no configura el timer3 
....................    if(!_T3_Config_Flag && _PWMx != Pin_C1 && _PWMx != Pin_C2)  
*
21E2:  BTFSC  1A.4
21E4:  BRA    2206
21E6:  MOVF   29,W
21E8:  SUBLW  11
21EA:  BZ    2206
21EC:  MOVF   29,W
21EE:  SUBLW  12
21F0:  BZ    2206
....................    { 
....................       setup_timer_3(T3_INTERNAL | T3_DIV_BY_2); 
21F2:  MOVLW  95
21F4:  MOVWF  FB1
....................       set_timer3(_Set_PWM_Timer3); 
21F6:  MOVLW  F6
21F8:  MOVWF  FB3
21FA:  MOVLW  9F
21FC:  MOVWF  FB2
....................        
....................       enable_interrupts(GLOBAL); 
21FE:  MOVLW  C0
2200:  IORWF  FF2,F
....................       enable_interrupts(INT_TIMER3); 
2202:  BSF    FA0.1
....................       _T3_Config_Flag = True;    //Indica que el Timer3 ya ha sido configurado 
2204:  BSF    1A.4
....................    }    
....................     
....................    //Si no es un pin de PWM por hardware, divide entre 5 el ciclo de trabajo  
....................    //para convertirlo en un valor entre 0 y 20 
....................    if(_PWMx != Pin_C1 && _PWMx != Pin_C2)    _DutyCycle /= 10; 
2206:  MOVF   29,W
2208:  SUBLW  11
220A:  BZ    2222
220C:  MOVF   29,W
220E:  SUBLW  12
2210:  BZ    2222
2212:  MOVFF  2A,2B
2216:  MOVLW  0A
2218:  MOVWF  2C
221A:  BRA    21B8
221C:  MOVFF  01,2A
....................    else 
2220:  BRA    2232
....................    { 
....................       if(!_T2_Config_Flag)          //Configura por única vez el Timer2 
2222:  BTFSC  1A.5
2224:  BRA    2232
....................       {   
....................          setup_timer_2(T2_DIV_BY_4, 100, 1); 
2226:  MOVLW  00
2228:  IORLW  05
222A:  MOVWF  FCA
222C:  MOVLW  64
222E:  MOVWF  FCB
....................          _T2_Config_Flag = True; 
2230:  BSF    1A.5
....................       } 
....................    } 
....................            
....................     
....................    if(_DutyCycle == 0) 
2232:  MOVF   2A,F
2234:  BTFSS  FD8.2
2236:  BRA    22EE
....................    { 
....................       switch(_PWMx)                  //Desactiva la salida PWM en el PIN deseado 
....................       {                  
2238:  MOVF   29,W
223A:  BZ    2272
223C:  XORLW  01
223E:  BZ    227A
2240:  XORLW  03
2242:  BZ    2282
2244:  XORLW  01
2246:  BZ    228A
2248:  XORLW  07
224A:  BZ    2292
224C:  XORLW  01
224E:  BZ    229A
2250:  XORLW  03
2252:  BZ    22A2
2254:  XORLW  01
2256:  BZ    22AA
2258:  XORLW  0F
225A:  BZ    22B2
225C:  XORLW  01
225E:  BZ    22BA
2260:  XORLW  03
2262:  BZ    22C2
2264:  XORLW  01
2266:  BZ    22CA
2268:  XORLW  1A
226A:  BZ    22D2
226C:  XORLW  03
226E:  BZ    22DC
2270:  BRA    22EA
....................          case 0: 
....................             _PWM0_Flag = False; 
2272:  BCF    19.0
....................             output_low(PWM0_PIN); 
2274:  BCF    F93.0
2276:  BCF    F8A.0
....................             break; 
2278:  BRA    22EC
....................          case 1: 
....................             _PWM1_Flag = False; 
227A:  BCF    19.1
....................             output_low(PWM1_PIN); 
227C:  BCF    F93.1
227E:  BCF    F8A.1
....................             break; 
2280:  BRA    22EC
....................          case 2: 
....................             _PWM2_Flag = False; 
2282:  BCF    19.2
....................             output_low(PWM2_PIN); 
2284:  BCF    F93.2
2286:  BCF    F8A.2
....................             break;    
2288:  BRA    22EC
....................          case 3: 
....................             _PWM3_Flag = False; 
228A:  BCF    19.3
....................             output_low(PWM3_PIN); 
228C:  BCF    F93.3
228E:  BCF    F8A.3
....................             break; 
2290:  BRA    22EC
....................          case 4: 
....................             _PWM4_Flag = False; 
2292:  BCF    19.4
....................             output_low(PWM4_PIN); 
2294:  BCF    F93.4
2296:  BCF    F8A.4
....................             break; 
2298:  BRA    22EC
....................          case 5: 
....................             _PWM5_Flag = False; 
229A:  BCF    19.5
....................             output_low(PWM5_PIN); 
229C:  BCF    F93.5
229E:  BCF    F8A.5
....................             break;    
22A0:  BRA    22EC
....................          case 6: 
....................             _PWM6_Flag = False; 
22A2:  BCF    19.6
....................             output_low(PWM6_PIN); 
22A4:  BCF    F93.6
22A6:  BCF    F8A.6
....................             break;    
22A8:  BRA    22EC
....................          case 7: 
....................             _PWM7_Flag = False; 
22AA:  BCF    19.7
....................             output_low(PWM7_PIN); 
22AC:  BCF    F93.7
22AE:  BCF    F8A.7
....................             break; 
22B0:  BRA    22EC
....................          case 8: 
....................             _PWM8_Flag = False; 
22B2:  BCF    1A.0
....................             output_low(PWM8_PIN); 
22B4:  BCF    F95.0
22B6:  BCF    F8C.0
....................             break; 
22B8:  BRA    22EC
....................          case 9: 
....................             _PWM9_Flag = False; 
22BA:  BCF    1A.1
....................             output_low(PWM9_PIN); 
22BC:  BCF    F95.1
22BE:  BCF    F8C.1
....................             break; 
22C0:  BRA    22EC
....................          case 10: 
....................             _PWM10_Flag = False; 
22C2:  BCF    1A.2
....................             output_low(PWM10_PIN); 
22C4:  BCF    F95.2
22C6:  BCF    F8C.2
....................             break; 
22C8:  BRA    22EC
....................          case 11: 
....................             _PWM11_Flag = False; 
22CA:  BCF    1A.3
....................             output_low(PWM11_PIN); 
22CC:  BCF    F92.4
22CE:  BCF    F89.4
....................             break;  
22D0:  BRA    22EC
....................          case Pin_C1: 
....................             setup_ccp2(CCP_OFF); 
22D2:  BSF    F94.1
22D4:  CLRF   FBA
....................             output_low(Pin_C1); 
22D6:  BCF    F94.1
22D8:  BCF    F8B.1
....................             break; 
22DA:  BRA    22EC
....................          case Pin_C2: 
....................             setup_ccp1(CCP_OFF); 
22DC:  BSF    F94.2
22DE:  CLRF   FBD
22E0:  CLRF   FB7
22E2:  CLRF   FB6
....................             output_low(Pin_C2); 
22E4:  BCF    F94.2
22E6:  BCF    F8B.2
....................             break;             
22E8:  BRA    22EC
....................          default: 
....................          break; 
22EA:  BRA    22EC
....................       } 
....................    } 
....................    else 
22EC:  BRA    23AA
....................    { 
....................       switch(_PWMx)                    //Asigna una salida PWM en el PIN deseado 
....................       {                  
22EE:  MOVF   29,W
22F0:  BZ    2328
22F2:  XORLW  01
22F4:  BZ    2330
22F6:  XORLW  03
22F8:  BZ    2338
22FA:  XORLW  01
22FC:  BZ    2340
22FE:  XORLW  07
2300:  BZ    2348
2302:  XORLW  01
2304:  BZ    2350
2306:  XORLW  03
2308:  BZ    2358
230A:  XORLW  01
230C:  BZ    2360
230E:  XORLW  0F
2310:  BZ    2368
2312:  XORLW  01
2314:  BZ    2370
2316:  XORLW  03
2318:  BZ    2378
231A:  XORLW  01
231C:  BZ    2380
231E:  XORLW  1A
2320:  BZ    2388
2322:  XORLW  03
2324:  BZ    2396
2326:  BRA    23A8
....................          case 0: 
....................             _PWM0_Flag = True; 
2328:  BSF    19.0
....................             _PWM0_DutyCycle = _DutyCycle; 
232A:  MOVFF  2A,1B
....................             break; 
232E:  BRA    23AA
....................          case 1: 
....................             _PWM1_Flag = True; 
2330:  BSF    19.1
....................             _PWM1_DutyCycle = _DutyCycle; 
2332:  MOVFF  2A,1C
....................             break; 
2336:  BRA    23AA
....................          case 2: 
....................             _PWM2_Flag = True; 
2338:  BSF    19.2
....................             _PWM2_DutyCycle = _DutyCycle; 
233A:  MOVFF  2A,1D
....................             break;    
233E:  BRA    23AA
....................          case 3: 
....................             _PWM3_Flag = True; 
2340:  BSF    19.3
....................             _PWM3_DutyCycle = _DutyCycle; 
2342:  MOVFF  2A,1E
....................             break; 
2346:  BRA    23AA
....................          case 4: 
....................             _PWM4_Flag = True; 
2348:  BSF    19.4
....................             _PWM4_DutyCycle = _DutyCycle; 
234A:  MOVFF  2A,1F
....................             break; 
234E:  BRA    23AA
....................          case 5: 
....................             _PWM5_Flag = True; 
2350:  BSF    19.5
....................             _PWM5_DutyCycle = _DutyCycle; 
2352:  MOVFF  2A,20
....................             break;    
2356:  BRA    23AA
....................          case 6: 
....................             _PWM6_Flag = True; 
2358:  BSF    19.6
....................             _PWM6_DutyCycle = _DutyCycle; 
235A:  MOVFF  2A,21
....................             break;    
235E:  BRA    23AA
....................          case 7: 
....................             _PWM7_Flag = True; 
2360:  BSF    19.7
....................             _PWM7_DutyCycle = _DutyCycle; 
2362:  MOVFF  2A,22
....................             break; 
2366:  BRA    23AA
....................          case 8: 
....................             _PWM8_Flag = True; 
2368:  BSF    1A.0
....................             _PWM8_DutyCycle = _DutyCycle; 
236A:  MOVFF  2A,23
....................             break; 
236E:  BRA    23AA
....................          case 9: 
....................             _PWM9_Flag = True; 
2370:  BSF    1A.1
....................             _PWM9_DutyCycle = _DutyCycle; 
2372:  MOVFF  2A,24
....................             break; 
2376:  BRA    23AA
....................          case 10: 
....................             _PWM10_Flag = True; 
2378:  BSF    1A.2
....................             _PWM10_DutyCycle = _DutyCycle; 
237A:  MOVFF  2A,26
....................             break; 
237E:  BRA    23AA
....................          case 11: 
....................             _PWM11_Flag = True; 
2380:  BSF    1A.3
....................             _PWM11_DutyCycle = _DutyCycle; 
2382:  MOVFF  2A,27
....................             break; 
2386:  BRA    23AA
....................          case Pin_C1:                        //PWM por hardware 
....................             setup_ccp2(CCP_PWM); 
2388:  BCF    F94.1
238A:  BCF    F8B.1
238C:  MOVLW  0C
238E:  MOVWF  FBA
....................             set_pwm2_duty(_DutyCycle); 
2390:  MOVFF  2A,FBB
....................             break; 
2394:  BRA    23AA
....................          case Pin_C2: 
....................             setup_ccp1(CCP_PWM);             //PWM por hardware 
2396:  BCF    F94.2
2398:  BCF    F8B.2
239A:  MOVLW  0C
239C:  MOVWF  FBD
239E:  CLRF   FB7
23A0:  CLRF   FB6
....................             set_pwm1_duty(_DutyCycle); 
23A2:  MOVFF  2A,FBE
....................             break; 
23A6:  BRA    23AA
....................          default: 
....................          break; 
23A8:  BRA    23AA
....................       } 
....................    } 
.................... } 
23AA:  RETURN 0
....................  
.................... //****************************************************************************// 
.................... //                               Timer3_Interrupt() 
.................... //****************************************************************************// 
.................... #INT_TIMER3 
.................... void Timer3_Interrupt() 
.................... {    
....................    set_timer3(_Set_PWM_Timer3); 
*
20AE:  MOVLW  F6
20B0:  MOVWF  FB3
20B2:  MOVLW  9F
20B4:  MOVWF  FB2
....................    static int8 T3_Counter = 1; 
....................     
....................    if(_PWM0_Flag) 
20B6:  BTFSS  19.0
20B8:  BRA    20CA
....................    { 
....................       if (T3_Counter <= _PWM0_DutyCycle) output_high(PWM0_PIN);  
20BA:  MOVF   28,W
20BC:  SUBWF  1B,W
20BE:  BNC   20C6
20C0:  BCF    F93.0
20C2:  BSF    F8A.0
....................       else output_low(PWM0_PIN); 
20C4:  BRA    20CA
20C6:  BCF    F93.0
20C8:  BCF    F8A.0
....................    } 
....................     
....................    if(_PWM1_Flag) 
20CA:  BTFSS  19.1
20CC:  BRA    20DE
....................    { 
....................       if (T3_Counter <= _PWM1_DutyCycle) output_high(PWM1_PIN);  
20CE:  MOVF   28,W
20D0:  SUBWF  1C,W
20D2:  BNC   20DA
20D4:  BCF    F93.1
20D6:  BSF    F8A.1
....................       else output_low(PWM1_PIN); 
20D8:  BRA    20DE
20DA:  BCF    F93.1
20DC:  BCF    F8A.1
....................    } 
....................     
....................    if(_PWM2_Flag) 
20DE:  BTFSS  19.2
20E0:  BRA    20F2
....................    { 
....................       if (T3_Counter <= _PWM2_DutyCycle) output_high(PWM2_PIN);  
20E2:  MOVF   28,W
20E4:  SUBWF  1D,W
20E6:  BNC   20EE
20E8:  BCF    F93.2
20EA:  BSF    F8A.2
....................       else output_low(PWM2_PIN); 
20EC:  BRA    20F2
20EE:  BCF    F93.2
20F0:  BCF    F8A.2
....................    } 
....................     
....................    if(_PWM3_Flag) 
20F2:  BTFSS  19.3
20F4:  BRA    2106
....................    { 
....................       if (T3_Counter <= _PWM3_DutyCycle) output_high(PWM3_PIN);  
20F6:  MOVF   28,W
20F8:  SUBWF  1E,W
20FA:  BNC   2102
20FC:  BCF    F93.3
20FE:  BSF    F8A.3
....................       else output_low(PWM3_PIN); 
2100:  BRA    2106
2102:  BCF    F93.3
2104:  BCF    F8A.3
....................    } 
....................     
....................    if(_PWM4_Flag) 
2106:  BTFSS  19.4
2108:  BRA    211A
....................    { 
....................       if (T3_Counter <= _PWM4_DutyCycle) output_high(PWM4_PIN);  
210A:  MOVF   28,W
210C:  SUBWF  1F,W
210E:  BNC   2116
2110:  BCF    F93.4
2112:  BSF    F8A.4
....................       else output_low(PWM4_PIN); 
2114:  BRA    211A
2116:  BCF    F93.4
2118:  BCF    F8A.4
....................    } 
....................     
....................    if(_PWM5_Flag) 
211A:  BTFSS  19.5
211C:  BRA    212E
....................    { 
....................       if (T3_Counter <= _PWM5_DutyCycle) output_high(PWM5_PIN);  
211E:  MOVF   28,W
2120:  SUBWF  20,W
2122:  BNC   212A
2124:  BCF    F93.5
2126:  BSF    F8A.5
....................       else output_low(PWM5_PIN); 
2128:  BRA    212E
212A:  BCF    F93.5
212C:  BCF    F8A.5
....................    } 
....................     
....................    if(_PWM6_Flag) 
212E:  BTFSS  19.6
2130:  BRA    2142
....................    { 
....................       if (T3_Counter <= _PWM6_DutyCycle) output_high(PWM6_PIN);  
2132:  MOVF   28,W
2134:  SUBWF  21,W
2136:  BNC   213E
2138:  BCF    F93.6
213A:  BSF    F8A.6
....................       else output_low(PWM6_PIN); 
213C:  BRA    2142
213E:  BCF    F93.6
2140:  BCF    F8A.6
....................    } 
....................     
....................    if(_PWM7_Flag) 
2142:  BTFSS  19.7
2144:  BRA    2156
....................    { 
....................       if (T3_Counter <= _PWM7_DutyCycle) output_high(PWM7_PIN);  
2146:  MOVF   28,W
2148:  SUBWF  22,W
214A:  BNC   2152
214C:  BCF    F93.7
214E:  BSF    F8A.7
....................       else output_low(PWM7_PIN); 
2150:  BRA    2156
2152:  BCF    F93.7
2154:  BCF    F8A.7
....................    } 
....................     
....................    if(_PWM8_Flag) 
2156:  BTFSS  1A.0
2158:  BRA    216A
....................    { 
....................       if (T3_Counter <= _PWM8_DutyCycle) output_high(PWM8_PIN);  
215A:  MOVF   28,W
215C:  SUBWF  23,W
215E:  BNC   2166
2160:  BCF    F95.0
2162:  BSF    F8C.0
....................       else output_low(PWM8_PIN); 
2164:  BRA    216A
2166:  BCF    F95.0
2168:  BCF    F8C.0
....................    } 
....................     
....................    if(_PWM9_Flag) 
216A:  BTFSS  1A.1
216C:  BRA    217E
....................    { 
....................       if (T3_Counter <= _PWM9_DutyCycle) output_high(PWM9_PIN);  
216E:  MOVF   28,W
2170:  SUBWF  24,W
2172:  BNC   217A
2174:  BCF    F95.1
2176:  BSF    F8C.1
....................       else output_low(PWM9_PIN); 
2178:  BRA    217E
217A:  BCF    F95.1
217C:  BCF    F8C.1
....................    } 
....................     
....................    if(_PWM10_Flag) 
217E:  BTFSS  1A.2
2180:  BRA    2192
....................    { 
....................       if (T3_Counter <= _PWM10_DutyCycle) output_high(PWM10_PIN);  
2182:  MOVF   28,W
2184:  SUBWF  26,W
2186:  BNC   218E
2188:  BCF    F95.2
218A:  BSF    F8C.2
....................       else output_low(PWM10_PIN); 
218C:  BRA    2192
218E:  BCF    F95.2
2190:  BCF    F8C.2
....................    } 
....................     
....................    if(_PWM11_Flag) 
2192:  BTFSS  1A.3
2194:  BRA    21A6
....................    { 
....................       if (T3_Counter <= _PWM11_DutyCycle) output_high(PWM11_PIN);  
2196:  MOVF   28,W
2198:  SUBWF  27,W
219A:  BNC   21A2
219C:  BCF    F92.4
219E:  BSF    F89.4
....................       else output_low(PWM11_PIN); 
21A0:  BRA    21A6
21A2:  BCF    F92.4
21A4:  BCF    F89.4
....................    } 
....................     
....................    T3_Counter ++; 
21A6:  INCF   28,F
....................    if(T3_Counter > _totalResolution) T3_Counter = 1; 
21A8:  MOVF   28,W
21AA:  SUBLW  0A
21AC:  BC    21B2
21AE:  MOVLW  01
21B0:  MOVWF  28
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... /* Reserved words and names definitions */ 
.................... #define digitalToggle   output_toggle 
.................... #define digitalWrite    output_bit 
.................... #define digitalRead     input 
....................  
.................... //****************************************************************************// 
.................... //                               analogRead(_Channel) 
.................... //Lee cualquiera de las entradas analógicas de la G-PiC Lite!. No es necesario 
.................... //poner un delay entre cada lectura, pues este tiempo está incluido dentro de la 
.................... //función. 
.................... // 
.................... //NOTA: Se emplea para lecturas de 8 bits de resolucion 
.................... //****************************************************************************// 
.................... #define AN0  0 
.................... #define A1  1 
.................... #define A2  2 
.................... #define A3  3 
.................... #define A4  4 
.................... #define A5  5 
.................... #define A6  6 
.................... #define A7  7 
.................... #define A8  8 
.................... #define A9  9 
.................... #define A10 10 
.................... #define A11 11 
.................... #define A12 12 
....................  
21B2:  BCF    FA1.1
21B4:  GOTO   2060
.................... int8 analogRead(int8 _Channel) 
.................... { 
....................    int8 _adcReading; 
....................     
....................    setup_adc(ADC_CLOCK_INTERNAL); 
....................    setup_adc_ports(ALL_ANALOG); 
....................    set_adc_channel(_Channel); 
....................    delay_us(10); 
....................     
....................    _adcReading = read_adc(); 
....................       
....................    setup_adc_ports(NO_ANALOGS); 
....................    return(_adcReading); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................    convert255to100(_value); 
....................     
....................    Recibe una variable con valores entre 0-255 y convierte los valores en un 
....................    rango entre 0-100. 
....................    Esta función es particularmente útil para asignar valores de porcentaje PWM 
.................... */ 
.................... int8 convert255to100(int8 _value) 
.................... { 
....................    return((_value*100.0)/255.0); 
.................... } 
.................... /******************************************************************************/ 
....................  
.................... /* 
....................    convertDECtoVolt(_value) 
....................    Recibe una variable con valores entre 0-255 y lo convierte a su equivalente 
....................    en voltaje entre 0V y 5V. Util para variables que contengan valores analógicos 
.................... */ 
.................... float convertDECtoVolt(float _value) 
.................... { 
....................    _value = (_value*5)/255; 
....................    return(_value); 
.................... } 
.................... /******************************************************************************/ 
....................  
.................... /* 
....................    convertDECtoDegree(_value) 
....................    Convierte el valor analogico leido de un LM35 y lo convierte en su equivalente 
....................    en grados. 
.................... */ 
.................... float convertDECtoDegree(float _value) 
.................... { 
....................    _value = 100*(_value*5)/255; 
....................    return(_value); 
.................... } 
.................... /******************************************************************************/ 
....................  
....................  
.................... #define Enable12  Pin_C1         //PWM por hardware en el Pin_C1 
.................... #define motor1A   Pin_B0         //Pin de control del puente H 
.................... #define motor2A   Pin_B1         //Pin de control del puente H 
....................  
.................... #define speed     50                //Constante para guardar la velocidad 
....................  
.................... void main() 
.................... { 
*
23D4:  CLRF   FF8
23D6:  BCF    FD0.7
23D8:  BSF    07.7
23DA:  CLRF   FEA
23DC:  CLRF   FE9
23DE:  BCF    1A.4
23E0:  BCF    1A.5
23E2:  MOVLW  01
23E4:  MOVWF  28
23E6:  MOVF   FC1,W
23E8:  ANDLW  C0
23EA:  IORLW  0F
23EC:  MOVWF  FC1
23EE:  MOVLW  07
23F0:  MOVWF  FB4
....................    digitalWrite(motor1A, 1);        //Define el sentido de giro del motor 
23F2:  BSF    F8A.0
23F4:  BCF    F93.0
....................    digitalWrite(motor2A, 0); 
23F6:  BCF    F8A.1
23F8:  BCF    F93.1
....................     
....................    while(true) 
....................    { 
....................       analogWrite(Enable12, speed); //Enciende el motor 
23FA:  MOVLW  11
23FC:  MOVWF  29
23FE:  MOVLW  32
2400:  MOVWF  2A
2402:  RCALL  21E2
....................       delay_ms(3000); 
2404:  MOVLW  0C
2406:  MOVWF  29
2408:  MOVLW  FA
240A:  MOVWF  2A
240C:  RCALL  23AC
240E:  DECFSZ 29,F
2410:  BRA    2408
....................       analogWrite(Enable12, 0);     //Apaga el motor 
2412:  MOVLW  11
2414:  MOVWF  29
2416:  CLRF   2A
2418:  RCALL  21E2
....................       delay_ms(3000); 
241A:  MOVLW  0C
241C:  MOVWF  29
241E:  MOVLW  FA
2420:  MOVWF  2A
2422:  RCALL  23AC
2424:  DECFSZ 29,F
2426:  BRA    241E
....................    } 
2428:  BRA    23FA
.................... } 
242A:  SLEEP 

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV20 VREGEN NOWDT WDT32768
   Word  3: 8500   CCP2C1 NOPBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
